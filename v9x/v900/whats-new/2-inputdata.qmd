---
title: Input Data
warning: false
message: false
echo: false
---

Changes made to the `1_Inputs` folder are discussed in this section.

```{python}
#|echo: false
# model folder
tdmOld = r"A:\1 - TDM\3 - Model Dev\1 - WF\1 - Official Release\v8x\v8.3.2\WF TDM v8.3.2 - 2022-02-04a"
tdmNew = r"A:\1 - TDM\3 - Model Dev\1 - WF\1 - Official Release\v9x\v9.0\WF TDM v9.0 - official"
```

```{python}
#|echo: false
# PREPROCESS GEOSPATIAL DATA
import os
import pandas as pd
import geopandas as gpd
import topojson as tp

fnTazOldIn    = tdmOld + r"\1_Inputs\1_TAZ\TAZ.shp"
fnTazNewIn    = tdmNew + r"\1_Inputs\1_TAZ\TAZ.shp"
fnK12EnrollIn = tdmNew + r"\1_Inputs\2_SEData\_ source - HBSch Enroll & Med Inc\K-12 Enrollment\k12_schools_enrollment\k12_schools_enrollment.shp"
fnCity        = tdmNew + r"\1_Inputs\1_TAZ\Districts\City_Name.dbf"
fnSDst        = tdmNew + r"\1_Inputs\1_TAZ\Districts\Dist_Small.dbf"
fnMDst        = tdmNew + r"\1_Inputs\1_TAZ\Districts\Dist_Medium.dbf"
fnLDst        = tdmNew + r"\1_Inputs\1_TAZ\Districts\Dist_Large.dbf"

fnDistrictsOld    = tdmNew + r"\1_Inputs\1_TAZ\TAZ.shp"

def writeGeoJson(in_path,out_path,fields):
  if not os.path.isfile(out_path):
    gdf = gpd.read_file(in_path)
    gdf = gdf[fields]
    gdf = gdf.to_crs({'init': 'epsg:4326'}) 
    topo = tp.Topology(gdf, prequantize=False)
    gdf_simplified = topo.toposimplify(.0001).to_gdf()
    gdf_simplified.to_file(out_path, driver='GeoJSON')
    return;

writeGeoJson(fnTazOldIn   , "data/tazOld.geojson"   , ['TAZID','CO_TAZID','geometry'])
writeGeoJson(fnTazNewIn   , "data/tazNew.geojson"   , ['TAZID','CO_TAZID','REMM','geometry'])
writeGeoJson(fnK12EnrollIn, "data/k12enroll.geojson", ['SchoolName','Enrol_Elem','Enrol_Midl','Enrol_High','PublicElem','PublicMidl','PublicHigh','PriChaElem','PriChaMidl','PriChaHigh','geometry'])
writeGeoJson(fnCity       , "data/city.geojson"     , ['CITY_NAME','geometry'])
writeGeoJson(fnSDst       , "data/sdst.geojson"     , ['DISTSML','DSML_NAME','geometry'])
writeGeoJson(fnMDst       , "data/mdst.geojson"     , ['DISTMED','DMED_NAME','geometry'])
writeGeoJson(fnLDst       , "data/ldst.geojson"     , ['DISTLRG','DLRG_NAME','geometry'])

# add median income to taz file
if not os.path.isfile('data/tazmedincome.geojson'):
  gdfTazNew = gpd.read_file("data/tazNew.geojson")
  dfMedIncome = pd.read_csv(tdmNew + r"\1_Inputs\2_SEData\_ source - HBSch Enroll & Med Inc\Median Income & VOT\for SE file -- TAZ Median Income - 2022-03-17.csv")
  gdfTazMedIncome = pd.DataFrame.merge(gdfTazNew,dfMedIncome,on='CO_TAZID',how='left')
  gdfTazMedIncome.to_file('data/tazmedincome.geojson', driver='GeoJSON')
```

::: {.content-visible when-format="html"}
```{ojs}
//|echo: false
// setup mapping and layers
L = require('leaflet@1.2.0')
html`<link href='${resolve('leaflet@1.2.0/dist/leaflet.css')}' rel='stylesheet' />`

geojsonTazOld    = FileAttachment("data/tazOld.geojson"   ).json()
geojsonTazNew    = FileAttachment("data/tazNew.geojson"   ).json()
geojsonK12Enroll = FileAttachment("data/k12enroll.geojson").json()
geojsonCity      = FileAttachment("data/city.geojson"     ).json()
geojsonSDst      = FileAttachment("data/sdst.geojson"     ).json()
geojsonMDst      = FileAttachment("data/mdst.geojson"     ).json()
geojsonLDst      = FileAttachment("data/ldst.geojson"     ).json()
```
:::

## Global Data
This section includes the changes made within the `0_GlobalData` subfolder.

### Trip Tables

The college base distribution file `BaseDistribution.csv` that contains the household locations of students in the base year was updated using new enrollment data sources. Dormitory populations were assigned to TAZs based on group quarter data from the census. The remaining enrollment was distributed using StreetLight origin-destination and USHE enrollment data. 

### Household Disaggregation and Auto Ownership

The age percent lookup file `Lookup - BYTAZAgePct - AllCo.csv` used in household disaggregation was replaced with the updated statewide file. The statewide file was updated based on 2020 Census block data, 2020 ACS block group data, and 2019 ACS population by age group data.

### Mode Choice

```{python}
# Convert bus speeds input into long format
import pandas as pd

# add name data to expand model CSV
dfAreaTypes = pd.DataFrame([
  ['Rur','Rural'     ],
  ['Trn','Transition'],
  ['Sub','Suburban'  ],
  ['Urb','Urban'     ],
  ['CBD','CBD-Like'  ]
], columns=('AreaType','AreaTypeName'))

dfTimePeriods = pd.DataFrame([
  ['Pk','Peak'    ],
  ['Ok','Off-Peak'],
  ['DY','Daily'   ]
], columns=('TimePeriod','TimePeriodName'))

dfFunctionalClasses = pd.DataFrame([
  [1, 'Col', 'Collectors & Locals'],
  [2, 'Min', 'Minor Arterials'    ],
  [3, 'Maj', 'Major Arterials'    ],
  [4, 'Exp', 'Expressways'        ],
  [5, 'Fwy', 'Freeways & Ramps'   ]
], columns=('FC','FunctionalClass','FunctionalClassName'))

# read in bus speed ratios
dfBusSpeedRatios = pd.read_csv(r"\\modelace\ModelAce-E\1 - TDM\2 - Sandbox\v9_Development\WF TDM v9.0 - 2023-04-28\1_Inputs\0_GlobalData\4_ModeChoice\bus_speed_ratios.csv").rename(columns={';FC':'FC'})

# create a list of column names to use as variable names
varCols = dfBusSpeedRatios.columns.to_list()

# remove the ID columns from variable columns list
varCols.remove('Functional Class')

# melt table to get long format using FC and FC Name as ids
dfBusSpeedRatios_long = pd.melt(dfBusSpeedRatios, id_vars=['FC'], value_vars=varCols, var_name='TimePeriod_AreaType', value_name='BusSpeedRatio')

# get Time Period and Area Type from TimePeriod_AreaType field
dfBusSpeedRatios_long['TimePeriod'] = dfBusSpeedRatios_long['TimePeriod_AreaType'].str.split('_').str[0]
dfBusSpeedRatios_long['AreaType'  ] = dfBusSpeedRatios_long['TimePeriod_AreaType'].str.split('_').str[1]

dfBusSpeedRatios_long = dfBusSpeedRatios_long.merge(dfFunctionalClasses,on='FC'        )
dfBusSpeedRatios_long = dfBusSpeedRatios_long.merge(dfTimePeriods      ,on='TimePeriod')
dfBusSpeedRatios_long = dfBusSpeedRatios_long.merge(dfAreaTypes        ,on='AreaType'  )

# limit columns and export csv
dfBusSpeedRatios_long = dfBusSpeedRatios_long[['FunctionalClass','FunctionalClassName','TimePeriod','TimePeriodName','AreaType','AreaTypeName','BusSpeedRatio']]

## create objects for observable js
#ojs_define(busdata = dfBusSpeedRatios_long, typed=True)
#ojs_define(fcnames = dfBusSpeedRatios_long[['FunctionalClassName']].drop_duplicates())
#ojs_define(tpnames = dfBusSpeedRatios_long[['TimePeriodName'     ]].drop_duplicates())
#ojs_define(atnames = dfBusSpeedRatios_long[['AreaTypeName'       ]].drop_duplicates())

dfBusSpeedRatios_long.to_csv(r'data\bus_speed_ratios_long.csv', index=False)

# export function class list csv
dfBusSpeedRatios_long[['FunctionalClass','FunctionalClassName']].drop_duplicates().to_csv('data\\functionalclass.csv', index=False)
dfBusSpeedRatios_long[['TimePeriod'     ,'TimePeriodName'     ]].drop_duplicates().to_csv('data\\timeperiod.csv'     , index=False)
dfBusSpeedRatios_long[['AreaType'       ,'AreaTypeName'       ]].drop_duplicates().to_csv('data\\areatype.csv'       , index=False)

dfBusSpeedRatios_Previous = pd.DataFrame([
   ['Collectors'                        , 0.60],
   ['Minor Arterials\n(Urb/CBD)'        , 0.65],
   ['Minor Arterials\n(Sub/Rur)'        , 0.65],
   ['Principal Arterials\n& Expressways', 0.55],
   ['Freeway Ramps'                     , 0.75],
   ['Freeways'                          , 0.95]
], columns=('FunctionalClass','BusSpeedRatio'))

dfBusSpeedRatios_Previous.to_csv(r'data\bus_speed_ratios_previous.csv', index=False)
```

::: {.content-hidden when-format="html"}
The bus speed ratios in the model were removed from the model scripts, as detailed in the *General Parameters* section, and were moved into a new file, `bus_speed_ratios.csv`.

In addtion to moving the location of the bus speed ratios, the ratios were further categorized and refined using real world bus speed data. Previously in version 8.3.2, bus speed ratios differed by functional type. A total of only 6 bus speed ratios existed, as shown in @fig-pdf-old-bus-speeds-plot. Now however in version 9, bus speed ratios differ by functional type, area type, and time of day. A total of 75 bus speed ratios now exist, as shown in @fig-pdf-bus-speeds-plot. The observed data used to develop the new bus speed ratios is the 2019 General Transit Feed Specification (GTFS) data, which includes schedules time and stop locations for all bus routes.

![Bus Speeds Plot - Version 8.3.2](_pictures/old_bus_speeds.png){#fig-pdf-old-bus-speeds-plot width=80%}

![Bus Speeds Plot - Version 9.0.0.](_pictures/pdf-bus-speeds-plot.png){#fig-pdf-bus-speeds-plot width=80%}
:::

::: {.content-visible when-format="html"}
The bus speed ratios in the model were removed from the model scripts, as detailed in the *General Parameters* section, and were moved into a new file, `bus_speed_ratios.csv`.

In addtion to moving the location of the bus speed ratios, the ratios were further categorized and refined using real world bus speed data as shown in @fig-bus-speed-ratios. Previously in version 8.3.2, bus speed ratios differed by functional type. A total of only 6 bus speed ratios existed. Now however in version 9, bus speed ratios differ by functional type, area type, and time of day. A total of 75 bus speed ratios now exist The observed data used to develop the new bus speed ratios is the 2019 General Transit Feed Specification (GTFS) data, which includes schedules time and stop locations for all bus routes.

::: {.panel-tabset}

#### Bus Speed Ratios Plot

```{ojs}


// read in CSVs
faDataBusSpeeds     = FileAttachment("data\\bus_speed_ratios_long.csv").csv({ typed: true });
faFunctionalClasses = FileAttachment("data\\functionalclass.csv"      ).csv({ typed: true });
faTimePeriods       = FileAttachment("data\\timeperiod.csv"           ).csv({ typed: true });
faAreaTypes         = FileAttachment("data\\areatype.csv"             ).csv({ typed: true });

viewof facetSelect  = Inputs.select(new Map([['Time Period', 'TimePeriodName'], ['Area Type', 'AreaTypeName'], ['Functional Class', 'FunctionalClassName']]), {value: 'TimePeriodName'     , label: "Columns:"});
viewof domainSelect = Inputs.select(new Map([['Time Period', 'TimePeriodName'], ['Area Type', 'AreaTypeName'], ['Functional Class', 'FunctionalClassName']]), {value: 'AreaTypeName'       , label: "X-Axis:"});
viewof strokeSelect = Inputs.select(new Map([['Time Period', 'TimePeriodName'], ['Area Type', 'AreaTypeName'], ['Functional Class', 'FunctionalClassName']]), {value: 'FunctionalClassName', label: "Series:"});

// FILTER DATA
//viewof functionalclasses_checked = Inputs.checkbox(faFunctionalClasses.map(function(d) {return d.FunctionalClassName}),
//                                                   {value: faFunctionalClasses.map(function(d) {return d.FunctionalClassName}),
//                                                    label: "Function Class"});
//viewof timeperiods_checked       = Inputs.checkbox(faTimePeriods      .map(function(d) {return d.TimePeriodName     }),
//                                                   {value: faTimePeriods      .map(function(d) {return d.TimePeriodName     }),
//                                                    label: "Time Period"   });
//filteredBusData = faDataBusSpeeds.filter(function(busspeed) {
//  return functionalclasses_checked.includes(busspeed.FunctionalClassName) &&
//         timeperiods_checked      .includes(busspeed.TimePeriodName     )// &&
//         //areatypes        .includes(busspeed.AreaTypeName  );
//});

domainFromSelect = {
  switch(domainSelect) {
    case 'TimePeriodName'     : return faTimePeriods      .map(function(d) {return d.TimePeriodName     }); break;
    case 'AreaTypeName'       : return faAreaTypes        .map(function(d) {return d.AreaTypeName       }); break;
    case 'FunctionalClassName': return faFunctionalClasses.map(function(d) {return d.FunctionalClassName}); break;
    default: return;
  }
}

//xPlotDomainSelect = {
//  switch(domainSelect) {
//    case 'TimePeriodName'     : return "TimePeriod"     ; break;
//    case 'AreaTypeName'       : return "AreaType"       ; break;
//    case 'FunctionalClassName': return "FunctionalClass"; break;
//    default: return;
//  }
//}

fLabel = {
  switch(facetSelect) {
    case 'TimePeriodName'     : return "Time Period"     ; break;
    case 'AreaTypeName'       : return "Area Type"       ; break;
    case 'FunctionalClassName': return "Functional Class"; break;
    default: return;
  }
}

xLabel = {
  switch(domainSelect) {
    case 'TimePeriodName'     : return "Time Period"     ; break;
    case 'AreaTypeName'       : return "Area Type"       ; break;
    case 'FunctionalClassName': return "Functional Class"; break;
    default: return;
  }
}

domainFacetSelect = {
  switch(facetSelect) {
    case 'TimePeriodName':
      return faTimePeriods.map(function(d) {
          return d.TimePeriodName
        });
      break;
    case 'AreaTypeName':
      return faAreaTypes.map(function(d) {
          return d.AreaTypeName
        });
      break;
    case 'FunctionalClassName':
      return faFunctionalClasses.map(function(d) {
          return d.FunctionalClassName
        });
      break;
    default:
      return; 
  }
}
```


```{ojs}
//|label: fig-bus-speed-ratios
//|fig-cap: Bus Speed Ratios
//|echo: false
Plot.plot({
  grid: true,
  aspectRatio: 0.25,
  facet: { data: faDataBusSpeeds, x: facetSelect, label: fLabel, marginTop: 40},
  x: {
    label: xLabel,
    domain: domainFromSelect,
    tickSize: 4,
    tickPadding: 2,
    marginTop: 40,
    tickRotate: 90,
  },
  y: {
    label: "Bus Speed Ratio",
    domain: [0, 1],
    fontSize: 8
  },
  color: { type: "categorical", legend: true, legendStyle: { fontSize: 16 } },
  style: {
    fontSize: 12
  },
  marginTop: 60,
  marginBottom: 120,
  marks: [
    Plot.frame(),
    Plot.line(faDataBusSpeeds, { x: domainSelect, y: "BusSpeedRatio", stroke: strokeSelect, strokeWidth: 2 }),
    Plot.dot(faDataBusSpeeds, { x: domainSelect, y: "BusSpeedRatio", stroke: strokeSelect, r: 4, fill: strokeSelect })
  ]
})

```

#### Bus Speed Ratios Data

```{ojs}
Inputs.table(faDataBusSpeeds, {
  style: {
    fontSize: 12,
  },
  columns: [
    "FunctionalClassName",
    "TimePeriodName",
    "AreaTypeName",
    "BusSpeedRatio"
  ],
  header: {
    FunctionalClassName: "Functional Class",
    TimePeriodName: "Time Period",
    AreaTypeName: "Area Type",
    BusSpeedRatio: "Bus Speed Ratio"
  }
})

```

#### Previous Bus Speed Ratios

```{ojs}

// read in CSVs
faDataBusSpeeds_previous = FileAttachment("data\\bus_speed_ratios_previous.csv").csv({ typed: true });
```

```{ojs}
//|label: fig-bus-speed-ratios-previous
//|fig-cap: Previous Bus Speed Ratios
//|echo: false

Plot.plot({
  grid: true,
  aspectRatio: 0.5,
  style: {
    fontSize: 12,
  },
  margin: 40,
  marginBottom: 150,
  x: {
    label: "",
    //tickFormat: () => "",
    tickRotate: 90,
    domain: faDataBusSpeeds_previous.map(function(d) {return d.FunctionalClass}),
    tickSize: 0
  },
  y: {label: "Bus Speed Ratio" , domain: [0, 1]},
  color: { type: "categorical", legend: false },
  marks: [
    Plot.frame(),
    Plot.barY(faDataBusSpeeds_previous, {x: "FunctionalClass", y: "BusSpeedRatio", stroke: "FunctionalClass", fill: "FunctionalClass"})
  ]  
})

```

:::

:::

### Assignment
As described in the *General Parameters* section, diurnal and production/attraction factors were moved out of the `0_GeneralParameters.block` file to an input file. The factors are now found in the `Time Of Day Factors.csv` file.

Most of the factors remained the same between model versions, except for the external trip purpose factors, as shown in @tbl-factor-change.

The new factors file also contains factors for more purposes, including home-based college purposes. Though the code has not been modified yet to account for these new purposes.

```{python}
#| echo: False
#| include: False
dfTodV832 = pd.read_csv('data/timeofdayfactors-v832-genparam.csv')
dfTodV832.rename(columns={'VALUE':'v832'}, inplace=True)

dfTodV832['FACTOR'] = dfTodV832['FACTOR'].str.upper()

# v9 factors
dfTodV900 = pd.read_csv(tdmNew + '/1_Inputs/0_GlobalData/5_Assignment/Time Of Day Factors.csv')
dfTodV900 = dfTodV900.melt(id_vars=[';ID','PURP'], var_name='SUFFIX',value_name='VALUE')
dfTodV900['FACTOR'] = dfTodV900['PURP'] + '_' + dfTodV900['SUFFIX']

dfTodV900 = dfTodV900[['FACTOR','VALUE']]
dfTodV900.rename(columns={'VALUE':'v900'}, inplace=True)

display(dfTodV900)

dfTod = pd.DataFrame.merge(dfTodV832,dfTodV900,on='FACTOR', how='outer')
dfTod['Difference'] = dfTod['v900'] - dfTod['v832']

dfTodWDiff = dfTod[dfTod['Difference']!=0].dropna()

dfTod.fillna('',inplace=True)

#display(dfTod)
dfTod.to_csv('test.csv')
#display(dfTodWDiff)
```

::: {.grid}
::: {.g-col-2}
:::
::: {.g-col-8}
```{python}
#| label: tbl-factor-change
#| tbl-cap: Time Of Day Factors with Changes
#| tbl-colwidths: [40,15,15,25]
from IPython.display import Markdown
from tabulate import tabulate
table = dfTodWDiff[['FACTOR','v900','v832','Difference']]
headers = ['Factor','v9 Value','v832 Value','Change']
Markdown(tabulate(table, 
  headers = headers,
  tablefmt="pipe", 
  colalign=['left','right','right','right'], 
  showindex=False,
  floatfmt=".4f" # Format for floating-point numbers
  )
)
```
:::
:::
## Traffic Analysis Zones (TAZ)

### Taz Geometry & Geographic Changes

TAZ geometry was updated and corrected.  These updates include:

 - Fixed the TAZ UTM NAD83 projection to use the standard for Utah rather than the ArcGIS default.
 - All TAZ boundaries align to county boundaries from the most current version on AGRC's website.
 - All internal TAZ topology was checked and corrected so there are no slivers, gaps, overlaps.

Internal zones were split to increase the model’s geographic resolution. Some zone boundaries were also modified without being split to better align with underlying land uses and planning boundaries.

The geographic coverage area of the internal zones was also expanded to encompass the entire county.  The notable exceptions to this are the portions of Box Elder County and Weber County that are not in the WFRC planning domain. While not expanded to county boundaries, the geographic coverage area of these counties was still changed to encompass the canyon/mountain areas that are part of the Wasatch Front travel shed.

External zones were revised to reflect the changes of the expanded internal zone area. This included an update to the number and location of the external zones. However, external zones are no longer represented in the TAZ shapefile. The arbitrary polygons representing the external zones in previous version of the TAZ shapefile have been removed. External zones are still represented in other parts of the model, such as in the highway network, general parameters block file.

The expanded area and reconfigured TAZs resulted in the addition of  688 internal zones and 6 external zones. A comparison of zone counts is found in @tbl-taz-count-internal and @tbl-taz-count-external.

::: {layout-ncol=2}
```{python}
#| label: tbl-taz-count-internal
#| tbl-cap: Internal TAZ Count Comparison
#| tbl-colwidths: [40,15,15,25]
import pandas as pd
from IPython.display import Markdown
from tabulate import tabulate
table = {
    'County': ['Box Elder', 'Weber', 'Davis', 'Salt Lake', 'Utah', 'Total'],
    'v9': [153, 428, 324, 1311, 1330, 3546],
    'v832': [135, 280, 231, 1127, 1085, 2858],
    'Change': [18, 148, 93, 184, 245, 688]
}
headers = ['County','v9','v832','Change']
Markdown(tabulate(table, 
  headers = headers,
  tablefmt="pipe", 
  colalign=("left",)*len(headers), 
  showindex=False)
)
```
```{python}
#| label: tbl-taz-count-external
#| tbl-cap: External TAZ Count Comparison
#| tbl-colwidths: [40,15,15,25]
import pandas as pd
from IPython.display import Markdown
from tabulate import tabulate
table = {
    'County': ['Box Elder', 'Weber', 'Davis', 'Salt Lake', 'Utah', 'Total'],
    'v9': [6, 3, 0, 6, 14, 29],
    'v832': [5, 3, 0, 7, 8, 23],
    'Change': [1, 0, 0, -1, 6, 6]
}
headers = ['County','v9','v832','Change']
Markdown(tabulate(table, 
  headers = headers,
  tablefmt="pipe", 
  colalign=("left",)*len(headers), 
  showindex=False)
)
```
:::

::: {.content-hidden when-format="html"}
The maps in @fig-taz-compare-weber-pdf, @fig-taz-compare-davis-pdf, @fig-taz-compare-sl-pdf, and @fig-taz-compare-utah-pdf show the difference in version 9 and version 8.3.2 TAZs.

```{python}
import matplotlib.pyplot as plt
import geopandas as gpd
# Define a function to generate CO_FIPS attribute based on CO_TAZID
def assign_fips(co_tazid):
    co_tazid_str = str(co_tazid)
    if co_tazid_str.startswith('30'):
        return '3'
    elif co_tazid_str.startswith('11'):
        return '11'
    elif co_tazid_str.startswith('35'):
        return '35'
    elif co_tazid_str.startswith('57'):
        return '57'
    elif co_tazid_str.startswith('49'):
        return '49'
    else:
        return None  # Handle other cases if needed

def plot_geo_data_by_fips(data_taz_new, data_taz_old, co_fips_value, line_color_new, line_color_old, line_width):    
    # Create the figure and axes
    fig, ax = plt.subplots(figsize=(15, 15))
    
    # Filter GeoDataFrames based on CO_FIPS value
    data_taz_new_filtered = data_taz_new.loc[data_taz_new['CO_FIPS'] == co_fips_value]
    data_taz_old_filtered = data_taz_old.loc[data_taz_old['CO_FIPS'] == co_fips_value]
    
    # Plot the filtered GeoDataFrames with different line colors and line width
    data_taz_new_filtered.plot(ax=ax, facecolor='none', edgecolor=line_color_new, linewidth=line_width)
    data_taz_old_filtered.plot(ax=ax, facecolor='none', edgecolor=line_color_old, linewidth=line_width)
    
    legend_ax = fig.add_axes([0.85, 0.5, 0.1, 0.1])
    legend_elements = [
        plt.Line2D([0], [0], color=line_color_new, linewidth=line_width, label='v9.0.0'),
        plt.Line2D([0], [0], color=line_color_old, linewidth=line_width, label='v8.3.2')
    ]
    legend_ax.legend(handles=legend_elements, loc='center')
    legend_ax.axis('off')
    
    # Display the plot
    plt.savefig("".join(['_pictures/pdf-taz-',co_fips_value]), bbox_inches='tight')
    #plt.show()
```

```{python}
import geopandas as gpd
import matplotlib.pyplot as plt

# Read the GeoJSON files
data_taz_new = gpd.read_file(r'D:\GitHub\TDM-Documentation\v9x\v900\whats-new\data\tazNew.geojson')
data_taz_old = gpd.read_file(r'D:\GitHub\TDM-Documentation\v9x\v900\whats-new\data\tazOld.geojson')

# Apply the function to create the CO_FIPS attribute
data_taz_new['CO_FIPS'] = data_taz_new['CO_TAZID'].apply(assign_fips)
data_taz_old['CO_FIPS'] = data_taz_old['CO_TAZID'].apply(assign_fips)

# Set the line colors and line width
line_color_new = '#0B2842'
line_color_old = '#789d4b'
line_width = 0.5
```

```{python}
#plot_geo_data_by_fips(data_taz_new, data_taz_old, '57', line_color_new, line_color_old, line_width)
#plot_geo_data_by_fips(data_taz_new, data_taz_old, '11', line_color_new, line_color_old, line_width)
#plot_geo_data_by_fips(data_taz_new, data_taz_old, '35', line_color_new, line_color_old, line_width)
#plot_geo_data_by_fips(data_taz_new, data_taz_old, '49', line_color_new, line_color_old, line_width)
```

![TAZ Geography Comparison Map -- Weber County.](_pictures/pdf-taz-57.png){#fig-taz-compare-weber-pdf width=75%}

![TAZ Geography Comparison Map -- Davix County.](_pictures/pdf-taz-11.png){#fig-taz-compare-davis-pdf width=75%}

![TAZ Geography Comparison Map -- Salt Lake County.](_pictures/pdf-taz-35.png){#fig-taz-compare-sl-pdf width=75%}

![TAZ Geography Comparison Map -- Utah County.](_pictures/pdf-taz-49.png){#fig-taz-compare-utah-pdf width=75%}

:::

::: {.content-visible when-format="html"}
The interactive map in @fig-taz-compare-map can be explored to visualize the difference in version 9 and version 8 TAZs.

```{ojs}
//|label: fig-taz-compare-map
//|fig-cap: TAZ Geography Comparison Map
//|echo: false

mapTaz = {

  let container = DOM.element('div', { style: `width:${width}px;height:${width/1.6}px` });
  yield container;
  
  let map = L.map(container).setView([40.7608, -111.8910], 8.25);

  let greyLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);

  let lcolors = ['#0000FF'    ,'red'   ]
  let llabels = ['v8.3.2 TAZ' ,'v9.0.0 TAZ'];

  let lyrTAZOld = L.geoJson(geojsonTazOld, { weight: 3.00, color: lcolors[0], fillOpacity: 0}).addTo(map);
  let lyrTAZNew = L.geoJson(geojsonTazNew, { weight: 1.50, color: lcolors[1], fillOpacity: 0}).addTo(map);

  var legend = L.control({position: 'bottomleft'});
    legend.onAdd = function (map) {
      var div = L.DomUtil.create('div', 'legend');
      div.innerHTML = '';
      for (var i = 0; i < llabels.length; i++) {
        div.innerHTML += '<i style="background:' + lcolors[i] + '">&nbsp;</i> ' + llabels[i] + '<br/>';
      }

      // Add CSS style for the background color
      div.style.backgroundColor = 'lightgray';
      div.style.padding = '10px';
      
      return div;
    };
    legend.addTo(map);
}
```
:::

The TAZ numbering was updated to reflect the changes made to the TAZ geometry, as depicted in @tbl-taz-ranges-internal and @tbl-taz-ranges-external. 

::: {layout-ncol=2}
```{python}
#| label: tbl-taz-ranges-internal
#| tbl-cap: Internal TAZ Ranges
#| tbl-colwidths: [30,33,33]
import pandas as pd
from IPython.display import Markdown
from tabulate import tabulate
table = {
    'County': ['Box Elder', 'Weber', 'Davis', 'Salt Lake', 'Utah', 'Total'],
    'v9': ['1-153','154-581','582-905','906-2216','2217-3546', '1-3546'],
    'v832': ['1-135','141-420','424-654','655-1781','1789-2873', '1-2873']
}
headers = ['County','v9','v832']
Markdown(tabulate(table, 
  headers = headers,
  tablefmt="pipe", 
  colalign=("left",)*len(headers), 
  showindex=False)
)
```
```{python}
#| label: tbl-taz-ranges-external
#| tbl-cap: External TAZ Ranges
#| tbl-colwidths: [30,33,33]
import pandas as pd
from IPython.display import Markdown
from tabulate import tabulate
table = {
    'County': ['Box Elder', 'Weber', 'Davis', 'Salt Lake', 'Utah', 'Total'],
    'v9': ['3601-3606','3607-3609','N/A','3610-3615','3616-3629', '3601-3629'],
    'v832': [  '136-140','421-423','N/A','1782-1788','2874-2881', '137-140, 421-423, 1782-1788, 2874-2881']
}
headers = ['County','v9','v832']
Markdown(tabulate(table, 
  headers = headers,
  tablefmt="pipe", 
  colalign=("left",)*len(headers), 
  showindex=False)
)
```
:::


### TAZ Attribute Changes
This section describes the changes made to the attributes of the TAZ shapefile.

#### REMM Space

::: {.content-hidden when-format="html"}
To indicate which TAZs are included in the Real Estate Market Model (REMM) area, a `REMM` field was added with a value of `1` indicating that it is part of REMM and `0` indicating it is not part of REMM, as shown in @fig-taz-remm-space-pdf.

```{python}
# Read the GeoJSON files
#import matplotlib.colors as colors
#data_taz_new = gpd.read_file(r'D:\GitHub\TDM-Documentation\v9x\v900\whats-new\data\tazNew.geojson')
#remm_values = data_taz_new['REMM'].astype(int)
#cmap = 'Accent_r'

#fig, ax = plt.subplots(figsize=(10, 10))
#data_taz_new.plot(column=remm_values, cmap=cmap, linewidth=0.5, ax=ax)

#legend_ax = fig.add_axes([0.85, 0.5, 0.1, 0.1]) 
#legend_elements = [
#    plt.Line2D([0], [0], color='green', linewidth=line_width, label='REMM Space'),
#    plt.Line2D([0], [0], color='gray', linewidth=line_width, label='Non-REMM Space')
#]
#legend_ax.legend(handles=legend_elements, loc='center')
#legend_ax.axis('off')

# Display the plot
#plt.show()
#plt.savefig('_pictures/pdf-remm', bbox_inches='tight')
```

![TAZ REMM Space.](_pictures/pdf-remm.png){#fig-taz-remm-space-pdf width=76%}

:::

::: {.content-visible when-format="html"}
To indicate which TAZs are included in the Real Estate Market Model (REMM) space, the `REMM` field was added with a value of `1` indicating that it is part of REMM and `0` indicating it is not part of REMM, as shown in @fig-taz-remm-space.

```{ojs}
//|label: fig-taz-remm-space
//|fig-cap: TAZ REMM Space
//|echo: false

mapTazRemmSpace = {

  let container = DOM.element('div', { style: `width:${width}px;height:${width/1.6}px` });
  yield container;
  
  let map = L.map(container).setView([40.7608, -111.8910], 8.25);

  let greyLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);

  let remmColors = ['#00887F'   ,'#BD0026'       ]
  let remmLabels = ['REMM Space','Non-REMM Space'];
  
  let lyrTAZNew = L.geoJson(geojsonTazNew, {
                            style: function(feature) {
                              var d = feature.properties.REMM;
                              return d==1 ? {color:remmColors[0], weight:1, opacity:0.95} :
                                     d==0 ? {color:remmColors[1], weight:1, opacity:0.95} : 
                                            {color:    '#000000', weight:1, opacity:0.95} ;
                            }
  }).addTo(map);
  
  var legend = L.control({position: 'bottomleft'});
  legend.onAdd = function (map) {
    var div = L.DomUtil.create('div', 'legend');
    div.innerHTML = '';
    for (var i = 0; i < remmLabels.length; i++) {
      div.innerHTML += '<i style="background:' + remmColors[i] + '">&nbsp;</i> ' + remmLabels[i] + '<br/>';
    }

    // Add CSS style for the background color
    div.style.backgroundColor = 'lightgray';
    div.style.padding = '10px';
    
    return div;
  };
  legend.addTo(map);
}
```
:::

#### Parking Costs
The permanent and temporary cost fields (`PRKCSTPERM` and `PRKCSTTEMP`) were updated to reflect current conditions and are in 2019 dollars. Costs for parking in the downtown areas of Salt Lake City, Ogden, and Provo and around the universities were based on 2022 parking rates obtained from Salt Lake City, web searches, and field visits. 

The Salt Lake City International Airport temporary parking cost was set to $1.25 based on a weighted average of short-term premium and economy rates. This represents a $0.25 (25%) increase from version 8.3.2 (version 8.3.2 parking costs were in 2010 dollars). Permanent parking costs were kept at $0 as workers at the airport do not pay for parking.

The Lagoon temporary parking cost was set to $6 based on the 2022 advertised parking rate of $18 per day by an assumed average occupancy of 3 people per vehicle. This represents a $1 (20%) increase from version 8.3.2. Similar to the airport, the cost of permanent parking at Lagoon was set to $0 as workers at Lagoon do not pay for parking.

#### District Definitions
Large, medium, and small districts were redefined and renamed. There are now 26 large districts, 73 medium districts, and 110 small districts. Medium districts still nest within large districts. Small districts were defined based on city area definitions and do not nest within medium districts.

### Additions to the `1_Inputs\1_TAZ` Folder
`_Source` was added to the `1_TAZ` folder. It includes the following shapefile data sets for ease of reference:

 - Cities
 - Counties
 - Environmental constraints
 - Previous TAZ versions.

`_ViewTAZDistricts` folder was added containing an ArcGIS Pro project with predefined symbology for viewing TAZ and district shapefiles.

Shapefiles representing the Wasatch Front subarea and the REMM vs. non-REMM area were added to the `1_TAZ\Districts` folder.

## Socioeconomic Data

Forecasts and control totals were updated based on new census data, updated base year parcel data, and the results of the REMM Model.

###  Forecasts
::: {.content-hidden when-format="html"}
The SE forecasts were updated for the WFRC areas. Box Elder updates were taken from the UDOT SE Forecasts from June 8, 2022. The updated SE forecasts can be found using the [Household and Job Forecasts Web App](https://wfrc.org/household-job-forecast-map). This map only contains the latest forecast and not any iterative step, such as the SE datasets in the model folder. Click on the *View Advanced Version* link in the header to enable the "Changes" option where you can see the change in forecasts between v8.3.2 and v9.
:::

::: {.content-visible when-format="html"}
The SE forecasts were updated for the WFRC areas. Box Elder updates were taken from the UDOT SE Forecasts from June 8, 2022. The updated SE forecasts can be found using the [Household and Job Forecasts Web App](https://wfrc.org/household-job-forecast-map). This map only contains the latest forecast and not any iterative step, such as the SE datasets in the model folder. Click on the *View Advanced Version* link in the header to enable the "Changes" option where you can see the change in forecasts between v8.3.2 and v9. You can explore the data in the embedded web application in @fig-household-job-forecast-map

```{ojs}
//|label: fig-household-job-forecast-map
//|fig-cap: Embedded Household and Job Forecast Map
//|echo: false

html`<div style="width: 765px; height: 680px; transform: scale(0.85); transform-origin: 0 0;">
         <iframe width="900" height="800" src="https://wfrc.org/household-job-forecast-map/" title="Household and Job Forecast"></iframe>
     </div>`
```
:::

### Control Totals
::: {.content-hidden when-format="html"}
Updates to the county control totals were made based on projections from the Gardner Policy Institute. The v8.3.2 model used a base year of 2015 for controls totals. v9 uses a base year of 2019. @fig-pdf-control-wf, @fig-pdf-control-weber, @fig-pdf-control-davis, @fig-pdf-control-sl, and @fig-pdf-control-utah show trends for control totals for residential and employment categories as well as and their control ratios. Various projections and historic data are plotted on the charts including household population, employment, average household size, jobs per houshold, worker population, etc.

As shown in @fig-pdf-control-utah, Utah County showed the largest decrease in control totals in the v9 model as compared to v8.3.2 with 107,937 lower population, 21,799 fewer households, and 47,977 fewer jobs (all employment). The largest job decreases are in office employment (14,923), government/education employment (16,982), and other employment (18,194). Utah County also has a significant drop in household size relative to other counties.

![Control Total: Wasatch Front](_pictures/pdf-control-wf.png){#fig-pdf-control-wf}

![Control Total: Weber County](_pictures/pdf-control-weber.png){#fig-pdf-control-weber}

![Control Total: Davis County](_pictures/pdf-control-davis.png){#fig-pdf-control-davis}

![Control Total: Salt Lake County](_pictures/pdf-control-sl.png){#fig-pdf-control-sl}

![Control Total: Utah County](_pictures/pdf-control-utah.png){#fig-pdf-control-utah}

:::

::: {.content-visible when-format="html"}
Updates to the county control totals were made based on projections from the Gardner Policy Institute. The v8.3.2 model used a base year of 2015 for controls totals. v9 uses a base year of 2019.

@fig-county-control-total-differences-by-category shows the 2050 differences in county control totals for any given socioeconomic category. 


```{python}
#| echo: false
import pandas as pd
import numpy as np

# County Control Totals
fnConTotOld = tdmOld + r"\1_Inputs\2_SEData\_ControlTotals\ControlTotal_SE_WF.csv"
fnConTotAgeOld = tdmOld + r"\1_Inputs\2_SEData\_ControlTotals\ControlTotal_Age.csv"
fnConTotNew = tdmNew + r"\1_Inputs\2_SEData\_ControlTotals\ControlTotal_SE_AllCounties.csv"

dfConTotOld = pd.read_csv(fnConTotOld)
dfConTotOld = dfConTotOld.rename(columns={'CoName':'CO_NAME'})
dfConTotOld['CO_NAME'] = dfConTotOld['CO_NAME'].str.replace(' County','')
dfConTotOld['ModelVersion'] = 'v8.3.2'

dfConTotAgeOld = pd.read_csv(fnConTotAgeOld)
dfConTotAgeOld = dfConTotAgeOld[['YEAR','CO_NAME','POP_18_64']]
dfConTotAgeOld['CO_NAME'] = dfConTotAgeOld['CO_NAME'].apply(lambda x: ' '.join([word.capitalize() for word in x.split()]))
dfConTotOld = pd.merge(dfConTotOld,dfConTotAgeOld, how = 'left', on = ['CO_NAME','YEAR'])
dfConTotOld['Job_HH'] = dfConTotOld['ALLEMP'] / dfConTotOld['HH']
dfConTotOld['WrkPop_Job'] = dfConTotOld['POP_18_64'] / dfConTotOld['ALLEMP']

dfConTotNew = pd.read_csv(fnConTotNew)
dfConTotNew = dfConTotNew[dfConTotNew['Subarea']=='1 - Wasatch Front'] # only WF area
dfConTotNew['ModelVersion'] = 'v9.0.0'

dfConTotCo = pd.concat([dfConTotOld,dfConTotNew])

dfConTotWF = pd.read_csv('data/wf-controltotal.csv')
dfConTotWF['ModelVersion'] = np.where(dfConTotWF['Source'] == ' CT_2022 ', 'v9.0.0','v8.3.2')
dfConTotWF = dfConTotWF.drop(columns={'Source'})
dfConTotWF['CO_NAME'] = 'Wasatch Front'
dfConTotWF['CO_FIPS'] = 00

sum_columns = dfConTotWF.columns[6:32]
grouped_df = dfConTotWF.groupby(['Subarea', 'CO_FIPS', 'CO_NAME', 'ModelVersion', 'YEAR'])[sum_columns].sum().reset_index()
ave_hh = dfConTotWF.groupby(['Subarea', 'CO_FIPS', 'CO_NAME', 'ModelVersion', 'YEAR'])['HH_Size'].mean().reset_index()
grouped_df['Job_HH'] = grouped_df['ALLEMP'] / grouped_df['HH']
grouped_df['WrkPop_Job'] = grouped_df['POP_18_64'] / grouped_df['ALLEMP']
grouped_df = grouped_df.drop(columns={'HH_Size'})
grouped_df = pd.merge(grouped_df,ave_hh, how='left')

dfConTot = pd.concat([dfConTotCo, grouped_df])
```

```{python}
dfConTot2 = dfConTot.fillna(0)
dfConTot2['Retail'] = dfConTot2['RETL'] + dfConTot2['FOOD']
dfConTot2['Industrial'] = dfConTot2['WSLE'] + dfConTot2['MANU']
dfConTot2['Other'] = dfConTot2['GVED'] + dfConTot2['HLTH'] + dfConTot2['OFFI'] + dfConTot2['OTHR']
dfConTot2['Typical'] = dfConTot2['Retail'] + dfConTot2['Industrial'] + dfConTot2['Other']

dfConTot_melt = pd.melt(dfConTot2, id_vars=('CO_NAME','YEAR','ModelVersion'), value_name='ControlTotal', var_name='Category', value_vars=('TOTPOP','GQ_Pop','HH_Pop','HH','HH_Size','POP_00_17','POP_18_64','POP_65P','ALLEMP','RETL','FOOD','MANU','WSLE','OFFI','GVED','HLTH','OTHR','AGRI','MING','CONS','HBJ','Job_HH','WrkPop_Job', 'Typical','Retail','Industrial','Other'))

dfConTot_melt.to_csv('data/controltotal.csv',index=False)
dfConTot_melt.groupby(['CO_NAME'],as_index=False).agg(COUNT=('YEAR','size')).to_csv('data/counties.csv',index=False)

# creat diff data
_df = dfConTot_melt[dfConTot_melt['YEAR']==2050]
_df = _df.pivot_table(index=['CO_NAME','Category'],columns='ModelVersion',values='ControlTotal')
_df = _df.dropna()
_df.reset_index(inplace=True)
_df['Difference'] = _df['v9.0.0'] - _df['v8.3.2']
_df['DifferencePct'] = _df['Difference'] / _df['v8.3.2']

_df_long = pd.melt(_df,
                   id_vars =['CO_NAME','Category'],
                   value_vars = ['Difference','DifferencePct'],
                   var_name = 'View',
                   value_name = 'ViewValue')    

#display(_df_long)
```

```{python}
#variable for ojs
ojs_define(diffConTot2050long = _df_long)
```


```{ojs}
//|echo: false

// read in CSVs
faControlTotals = FileAttachment("data/controltotal.csv").csv({ typed: true });
faCounties      = FileAttachment("data/counties.csv"    ).csv({ typed: true });

cats = new Map([//['Total Population'               , 'TOTPOP'    ],
                //['Group Quarter Population'       , 'GQ_Pop'    ],
                ['Population'                     , 'HH_Pop'    ],
                ['Households'                     , 'HH'        ],
                //['Household Size'                 , 'HH_Size'   ],
                //['Population 0-17'                , 'POP_00_17' ],
                //['Population 18-64'               , 'POP_18_64' ],
                //['Population 65+'                 , 'POP_65P'   ],
                ['All Employment'                 , 'ALLEMP'    ],
                ['Retail Employment'              , 'RETL'      ],
                ['Food Employment'                , 'FOOD'      ],
                ['Manufacturing Employment'       , 'MANU'      ],
                ['Wholesale Employment'           , 'WSLE'      ],
                ['Office Employment'              , 'OFFI'      ],
                ['Government/Education Employment', 'GVED'      ],
                ['Health Employment'              , 'HLTH'      ],
                ['Other Employment'               , 'OTHR'      ],
                //['Agriculture Employment'         , 'AGRI'      ],
                //['Mining Employment'              , 'MING'      ],
                //['Construction Employment'        , 'CONS'      ],
                ['Home-Based Job Employment'      , 'HBJ'       ]
                //['Jobs per Household'             , 'Job_HH'    ],
                //['Working Population per Job'     , 'WrkPop_Job']
                ])
```


```{ojs}
// FILTER DATA
filteredControlTotals = faControlTotals.filter(function(ct) {
  return selectCounty   == ct.CO_NAME &&
         selectCategory == ct.Category;
});
viewof selectCategory = Inputs.select(cats, {value: 'HH_Pop', label: 'Category: '});

viewof metric = Inputs.radio(new Map([["Difference", "Difference"], ["Percent Difference", "DifferencePct"]]), {value: "Difference", label: "Display:"})
```

```{ojs}
dataCTDiff50 = transpose(diffConTot2050long)
filtered_dataCTDiff50 = dataCTDiff50.filter(function(dataL) {
    return selectCategory == dataL.Category  &&
           metric == dataL.View;
})
```

```{ojs}
//https://observablehq.com/@d3/diverging-bar-chart
import {DivergingBarChart} from "@d3/diverging-bar-chart"

function getXFormat() {
  if (metric === "DifferencePct") {
    return "+%";
  } else if (selectCategory === 'HH_Size' && metric === "Difference") {
    return ".2f";
  } else {
    return "+,d";
  }
}

```

```{ojs}
//|label: fig-county-control-total-differences-by-category
//|fig-cap: 2050 Differences in Control Totals for Selected Category (v9.0 vs v8.3.2)
//|echo: false

chart3 = DivergingBarChart(filtered_dataCTDiff50, {
    x: d => d.ViewValue,
    y: d => d.CO_NAME,
    xFormat: getXFormat(),
    xLabel: "2050 Difference",
    aspectRatio: 0.5,
    colors: d3.schemeRdBu[3],
    yDomain: ['Weber','Davis','Salt Lake','Utah', 'Wasatch Front']
})
```

Utah County displays the largest decrease in control totals in the v9 model as compared to v8.3.2 with 107,937 lower population, 21,799 fewer households, and 47,977 fewer jobs (all employment). The largest job decreases are in office employment (14,923), government/education employment (16,982), and other employment (18,194). Utah County also has a significant drop in household size relative to other counties.

Further trends for county specific residential and employment control totals as well as control total ratios are shown in @fig-county-control-trends-by-county-by-category.

```{ojs}
viewof selectCounty = Inputs.select(new Map(['Wasatch Front', 'Weber', 'Davis', 'Salt Lake', 'Utah'].map(county => [county, county])), {value: 'Wasatch Front', label: 'County: '});

// FILTER DATA
filteredCTPlot = faControlTotals.filter(function(ct) {
  return selectCounty   == ct.CO_NAME; //&&
         //selectCategoryPlot == ct.Category;
});
maxY1 = Math.max(...filteredCTPlot.map(item => item.ControlTotal));

// FILTER DATA for employment control totals
filteredCTPlot2 = faControlTotals.filter(function(ct) {
  return selectCounty   == ct.CO_NAME &&
         ["Typical", "Retail", "Industrial", "Other"].includes(ct.Category);
});
maxY2 = Math.max(...filteredCTPlot2.map(item => item.ControlTotal));

// FILTER DATA for control totals ratios
filteredCTPlot3 = faControlTotals.filter(function(ct) {
  return selectCounty   == ct.CO_NAME &&
         ["HH_Size", "Job_HH", "WrkPop_Job"].includes(ct.Category);
});
maxY3 = Math.max(...filteredCTPlot3.map(item => item.ControlTotal));
```


```{ojs}
// data for the residential control totals
hhPopData8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "HH_Pop" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
hhPopData9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "HH_Pop" == ct.Category && "v9.0.0" == ct.ModelVersion;})
hhData8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "HH" == ct.Category && 'v8.3.2' == ct.ModelVersion  && ct.YEAR > 2020;})
hhData9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "HH" == ct.Category && 'v9.0.0' == ct.ModelVersion;})

// data for the employment control totals
typicalData8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Typical" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
typicalData9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Typical" == ct.Category && "v9.0.0" == ct.ModelVersion;})
retailData8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Retail" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
retailData9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Retail" == ct.Category && "v9.0.0" == ct.ModelVersion;})
industrialData8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Industrial" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
industrialData9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Industrial" == ct.Category && "v9.0.0" == ct.ModelVersion;})
otherData8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Other" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
otherData9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Other" == ct.Category && "v9.0.0" == ct.ModelVersion;})

// data for control total ratios
hhsize8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "HH_Size" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
hhsize9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "HH_Size" == ct.Category && "v9.0.0" == ct.ModelVersion;})
jobhh8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Job_HH" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
jobhh9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "Job_HH" == ct.Category && "v9.0.0" == ct.ModelVersion;})
wrkpop8 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "WrkPop_Job" == ct.Category && "v8.3.2" == ct.ModelVersion  && ct.YEAR > 2020;})
wrkpop9 = faControlTotals.filter(function(ct) { return selectCounty == ct.CO_NAME && "WrkPop_Job" == ct.Category && "v9.0.0" == ct.ModelVersion;})
```

```{ojs}
//|label: fig-county-control-trends-by-county-by-category
//|fig-cap: Control Total Trends for Selected County for Selected Category
//|fig-subcap:
//|   - "Residential Control Total"
//|   - "Employment Control Total"
//|   - "Control Total Ratios"
//|echo: false

Plot.plot({
  grid: true,
  aspectRatio: 0.5,
  x: {label: 'Year', tickFormat: d => d},
  y: {label: 'Control Total', domain: [0, maxY1]},
  marginRight:60,
  marginLeft: 60,
  style: {
    fontSize: 15
  },
  marginTop: 60,
  marginBottom: 60,
  marks: [
    Plot.line(
      hhPopData8, {x: 'YEAR', y: 'ControlTotal', stroke: '#5b859e', strokeWidth: 2, strokeDasharray: '5,5'}),
    Plot.line(
      hhPopData9, {x: 'YEAR', y: 'ControlTotal', stroke: '#1e395f', strokeWidth: 2, text: ['yo momma']}),
    Plot.text(
      hhPopData9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),
    
    Plot.line(
      hhData8, {x: 'YEAR', y: 'ControlTotal', stroke: '#75884b',strokeWidth: 2,strokeDasharray: '5,5'}),
    Plot.line(
      hhData9, {x: 'YEAR', y: 'ControlTotal', stroke: '#1e5a46',strokeWidth: 2}),
    Plot.text(
      hhData9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),
    
    Plot.frame({strokeOpacity: 0.2}),
    [
      Plot.text([`\n   ——   Current Projection \n\n   —  — Previous Projection`], {frameAnchor: "top-left", fontSize: 14})
  ]]
})

Plot.plot({
  grid: true,
  aspectRatio: 0.5,
  x: {label: 'Year', tickFormat: d => d},
  y: {label: 'Control Total', domain: [0, maxY2]},
  marginRight:80,
  marginLeft: 60,
  style: {
    fontSize: 15
  },
  marginTop: 60,
  marginBottom: 60,
  marks: [
    Plot.line(
      typicalData8, {x: 'YEAR', y: 'ControlTotal', stroke: '#FF6666', strokeWidth: 2, strokeDasharray: '5,5'}),
    Plot.line(
      typicalData9, {x: 'YEAR', y: 'ControlTotal', stroke: '#FF0000', strokeWidth: 2}),
    Plot.text(
      typicalData9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.line(
      retailData8, {x: 'YEAR', y: 'ControlTotal', stroke: '#75884b',strokeWidth: 2,strokeDasharray: '5,5'}),
    Plot.line(
      retailData9, {x: 'YEAR', y: 'ControlTotal', stroke: '#1e5a46',strokeWidth: 2}),
    Plot.text(
      retailData9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.line(
      industrialData8, {x: 'YEAR', y: 'ControlTotal', stroke: '#A0A0A0', strokeWidth: 2, strokeDasharray: '5,5'}),
    Plot.line(
      industrialData9, {x: 'YEAR', y: 'ControlTotal', stroke: '#606060', strokeWidth: 2}),
    Plot.text(
      industrialData9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.line(
      otherData8, {x: 'YEAR', y: 'ControlTotal', stroke: '#5b859e',strokeWidth: 2,strokeDasharray: '5,5'}),
    Plot.line(
      otherData9, {x: 'YEAR', y: 'ControlTotal', stroke: '#1e395f',strokeWidth: 2}),
    Plot.text(
      otherData9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.frame({strokeOpacity: 0.2}),
    [
      Plot.text([`\n   ——   Current Projection \n\n   —  — Previous Projection`], {frameAnchor: "top-left", fontSize: 14})
  ]]
})

Plot.plot({
  grid: true,
  aspectRatio: 0.5,
  x: {label: 'Year', tickFormat: d => d},
  y: {label: 'Control Total', domain: [0, maxY3]},
  marginRight:85,
  marginLeft: 60,
  style: {
    fontSize: 15
  },
  marginTop: 60,
  marginBottom: 60,
  marks: [
    Plot.line(
      hhsize8, {x: 'YEAR', y: 'ControlTotal', stroke: '#5b859e', strokeWidth: 2, strokeDasharray: '5,5'}),
    Plot.line(
      hhsize9, {x: 'YEAR', y: 'ControlTotal', stroke: '#1e395f', strokeWidth: 2}),
    Plot.text(
      hhsize9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.line(
      jobhh8, {x: 'YEAR', y: 'ControlTotal', stroke: '#75884b',strokeWidth: 2,strokeDasharray: '5,5'}),
    Plot.line(
      jobhh9, {x: 'YEAR', y: 'ControlTotal', stroke: '#1e5a46',strokeWidth: 2}),
    Plot.text(
      jobhh9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.line(
      wrkpop8, {x: 'YEAR', y: 'ControlTotal', stroke: '#FFB266',strokeWidth: 2,strokeDasharray: '5,5'}),
    Plot.line(
      wrkpop9, {x: 'YEAR', y: 'ControlTotal', stroke: '#FF8000',strokeWidth: 2}),
    Plot.text(
      wrkpop9, Plot.selectLast({x: "YEAR", y: "ControlTotal", text: "Category", textAnchor: "start", dx: 3})),

    Plot.frame({strokeOpacity: 0.2}),
    [
      Plot.text([`\n   ——   Current Projection \n\n   —  — Previous Projection`], {frameAnchor: "top-left", fontSize: 14})
  ]]
})
```
:::

### School Enrollment
::: {.content-hidden when-format="html"}
The Kindergarten through 12th grade (K-12) enrollment data was updated using the 2019 statewide school enrollment database. This was done at the state-wide level and then applied to the Wasatch Front. 
:::

::: {.content-visible when-format="html"}
The Kindergarten through 12th grade (K-12) enrollment data was updated using the 2019 statewide school enrollment database. This was done at the state-wide level and then applied to the Wasatch Front. Additionally, a point shapefile of the state-wide dataset is included with the TDM, as shown in @fig-school-locations.
```{ojs}
//|label: fig-school-locations
//|fig-cap: K-12 School Locations
//|echo: false

mapK12Enroll = {

  let container = DOM.element('div', { style: `width:${width}px;height:${width/1.6}px` });
  yield container;
  
  let map = L.map(container).setView([40.7608, -111.8910], 8.25);

  let greyLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);

  var cHigh = "#FF0000"
  var cMidl = "#00FF00"
  var cElem = "#0000FF"

  var geojsonMarkerOptions_High = {
      radius: 4,
      fillColor: cHigh,
      color: cHigh,
      weight: 2,
      opacity: 1,
      fillOpacity: 1.0,
  };

  var geojsonMarkerOptions_Midl = {
      radius: 4,
      fillColor: cMidl,
      color: cMidl,
      weight: 2,
      opacity: 1,
      fillOpacity: 1.0,
  };
  var geojsonMarkerOptions_Elem = {
      radius: 4,
      fillColor: cElem,
      color: cElem,
      weight: 2,
      opacity: 1,
      fillOpacity: 1.0,
  };
            
  // function to use different icons based on number of stations
  function markerByEnrollment(feature) {
    if (feature.properties.Enrol_High >= 100) {
      return geojsonMarkerOptions_High
    } else if (feature.properties.Enrol_Midl >= 100){
      return geojsonMarkerOptions_Midl;
    } else{
      return geojsonMarkerOptions_Elem;
    }
  };

  function getColor(c) {
    if (c=='High School') {
      return cHigh;
    } else if (c=='Middle School') {
      return cMidl;
    } else if (c=='Elementary School') {
      return cElem;
    }
  };
          
  // create the GeoJSON layer and call the styling function with each marker
  var layerSchools = L.geoJSON(geojsonK12Enroll,  {
    pointToLayer: function (feature, latlng) {
      var mypopup = L.popup().setContent("<b>" + feature.properties.SchoolName + " Enrollment</b>" +
                    "<br><b>High School: </b>" + feature.properties.Enrol_High +
                    "<br><b>Middle School: </b>" + feature.properties.Enrol_Midl +
                    "<br><b>Elementary School: </b>" + feature.properties.Enrol_Elem);
      var mymarker = L.circleMarker(latlng, markerByEnrollment(feature));
      mymarker.bindPopup(mypopup);
      return mymarker;
    }
  }).addTo(map);

  var legend = L.control({position: 'bottomleft'});
    legend.onAdd = function (map) {
      var div = L.DomUtil.create('div', 'info legend');
      var labelsBill = []; // legend title
      var lcategories = ['High School','Middle School','Elementary School'];

      for (var i = 0; i < lcategories.length; i++) {
        div.innerHTML += 
          labelsBill.push(
            '<i class="bi bi-circle-fill" style="color:' + getColor(lcategories[i]) + '"></i> ' +
          (lcategories[i] ? lcategories[i] : '+'));
      }
      div.innerHTML = labelsBill.join('<br>');

      // Add CSS style for the background color
      div.style.backgroundColor = 'lightgray';
      div.style.padding = '10px';
      
      return div;
    };
    legend.addTo(map);

  //let lyrK12Enroll = L.geoJson(geojsonK12Enroll, { size: 5, color: '#FFFFFF'}).addTo(map);
  
}
```
:::

### Median Income

Median income & value-of-time (VOT) inputs for the model were updated with 2019 data and used to update the TAZ Median Income in the TAZ file.

## Highway Network

The highway network was expanded to incorporate the new model areas. See <a href="#geographies">TAZ Geographies</a>. The 2023 RTP fields have been updated to reflect the adopted 2023 RTP.

### Highway Node Numbering Schema
Updates to the highway node numbering schema are shown in @tbl-master-network-node-numbering-schema. An additional reference file called `_Node Definition - v832 & v9.xlsx` is found in the `3_Highway` folder.

::: {.grid}
::: {.g-col-2}
:::
::: {.g-col-8}
```{python}
#| label: tbl-master-network-node-numbering-schema
#| tbl-cap: Master Network Node Numbering Schema
#| echo: False
from IPython.display import Markdown
from tabulate import tabulate
table = [['WFRC'   , '10,000 - 19,999', '20,000 - 49,999', '90,000 - 94,999'],
         ['MAG'    , '50,000 - 59,999', '60,000 - 89,999', '95,000 - 99,999']]
Markdown(tabulate(
  table, 
  headers=["MPO","Transit Nodes", "Highway Nodes", "v9 Expansion Areas"]
))
```
:::
:::

The highway network updates include the following: 

- Updated Commuter-Rail Transit (CRT) Fare Zone
    - Vineyard & Orem stations were modified to have the same fare zone (similar to North Temple & Central)
    - Updated and fixed fare zone definitions in WFRC area
- Fixed small network error in Box Elder where a local road was drawn to the centroid of v8.3.2 TAZ 53
- A few edits to WFRC draft RTP project list
- Updated segment ids
    - Made consistent with the latest segment shapefile
    - Updated segments to account for recent network changes & add segment definitions to account for rail transit
- Added `SEGEX_RTP` & `SEGEX_NEED` as text fields (to be populated later when script/processing updated). These are segment ID exception fields where the future SEGIDs are different than existing SEGIDs.
- Phase change for Managed Motorways in WFRC area
- A couple of phasing updates from the WFRC RTP project list
- Cleaned up `GIS23_32` and `GIS23_42` fields
- Differentiated what projects will be built by 2028 from what will be built by 2023
- Rail `SEGID` additions were made to allow for easier transit result visualization.

Additionally, a `MergedMasterNet - 2022-09-19a` folder was added to serve as a workspace for editing and updating Merged Master Network and for exporting to v8.3.2 & v9 master networks.

## Transit
The transit line files and CUBE Public Transport (PT) files were updated to correspond with the 2023 RTP:

- 2019 was thoroughly vetted to represent Aug 2019 change day
- 2023: updated route alignment, headways & stops based on August 2022 change day (WFRC & MAG)
- 2028: updated route alignment, headways & stops based on UTA 5-Year Service Plan (WFRC & MAG)
- RTP 2032, 2042 & 2050: rolled 2028 changes forward into plan phased years & updated based on 2023 draft plan
- Needs 2032, 2042 & 2050: rolled 2028 changes forward into plan phased years & updated based on 2023 draft plan

Route S902 was updated so route no longer go to the I-80 Parleys Canyon external node.

### Public Transport (PT) Parameters

The fare files were updated with 2019 fare data. The fares were updated to match the actual advertised fares, whereas the v8.3.2 model contained a 46% adjustment fares. This reduction accounts for monthly pass, education, fare-pay, senior, employer paid, and other discounts. This adjustment is now explicitly defined, as was discussed in the *General Parameters* section.
        
### General Hand-Coded Support Links
`General_hand_coded_walk_links.NTL` files were reviewed and updated.

### Transit Route Tester

A route tester script was added in the `_chk Transit Compile on Net` folder. The script checks to see if transit line files for the respective scenario compile on the scenario highway network. This can be used for reviewing transit line edits outside of the model stream.

```{python}
#|echo: false
# get externals mapping layers

import os
import pandas as pd
import geopandas as gpd
import topojson as tp

if not os.path.isfile('data/masternetlink.geojson'):
  gdfMasterNetLink = gpd.read_file(r"A:\1 - TDM\1 - Input Dev\5 - External\_GIS_Layers\Master Net\MasterNet - 2022-07-29_Link.shp")
  gdfMasterNetLink = gdfMasterNetLink.to_crs({'init': 'epsg:4326'}) 
  gdfMasterNetLink = gdfMasterNetLink[gdfMasterNetLink['FT_2019']>1]
  gdfMasterNetLink = gdfMasterNetLink[['LINKID','FLG_NEWNET','geometry']]
  topo = tp.Topology(gdfMasterNetLink, prequantize=False)
  gdfMasterNetLink = topo.toposimplify(.0001).to_gdf()
  gdfMasterNetLink.to_file('data/masternetlink.geojson', driver='GeoJSON')

if not os.path.isfile('data/masternetnode.geojson'):
  gdfMasterNetNode = gpd.read_file(r"A:\1 - TDM\1 - Input Dev\5 - External\_GIS_Layers\Master Net\MasterNet - 2022-07-29_Node.shp")
  gdfMasterNetNode = gdfMasterNetNode.to_crs({'init': 'epsg:4326'}) 
  gdfMasterNetNode = gdfMasterNetNode[['N','EXTERNAL','EXT_V9','geometry']]
  topo = tp.Topology(gdfMasterNetNode, prequantize=False)
  gdfMasterNetNode = topo.toposimplify(.0001).to_gdf()
  gdfMasterNetNode.to_file('data/masternetnode.geojson', driver='GeoJSON')

if not os.path.isfile('data/externalold.geojson'):
  gdfMasterNetNode = gpd.read_file('data/masternetnode.geojson')
  gdfExtNew = gdfMasterNetNode[gdfMasterNetNode['EXTERNAL']==1]
  gdfExtNew.to_file('data/externalold.geojson', driver='GeoJSON')

if not os.path.isfile('data/externalnew.geojson'):
  gdfMasterNetNode = gpd.read_file('data/masternetnode.geojson')
  gdfExtNew = gdfMasterNetNode[gdfMasterNetNode['EXT_V9']==1]
  gdfExtNew.to_file('data/externalnew.geojson', driver='GeoJSON')

```

## Externals

::: {.content-hidden when-format="html"}
External locations and forecasts were updated. The locations of the former and updated location of externals is shown in @fig-externals-pdf. Forecasts through 2060 were generated for the updated external locations using historical data through 2019.

![v9 External Description.](_pictures/externals.png){#fig-externals-pdf width=76%}

:::

::: {.content-visible when-format="html"}
External locations and forecasts were updated. The locations of the former and updated location of externals is shown in @fig-externals. Forecasts through 2060 were generated for the updated external locations using historical data through 2019.

```{ojs}
//|echo: false
geojsonExternalOld   = FileAttachment("data/externalold.geojson"  ).json()
geojsonExternalNew   = FileAttachment("data/externalnew.geojson"  ).json()
geojsonMasterNetLink = FileAttachment("data/masternetlink.geojson").json()
```

```{ojs}
//|label: fig-externals
//|fig-cap: Externals
//|echo: false

mapExternals = {

  let container = DOM.element('div', { style: `width:${width}px;height:${width/1.6}px` });
  yield container;
  
  let map = L.map(container).setView([40.7608, -111.8910], 8.25);

  let osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map); 

  var cNew = "#FF0000";
  var cOld = "#00FF00";

  var squareIcon_New = L.icon({
    iconUrl: 'https://wfrc.org/wftdm-docs/_pictures/square_green.png',  // Replace with the path to your square-like icon image
    iconSize: [15, 15],          // Adjust the size of the square-like icon
    iconAnchor: [5, 5],          // Adjust the anchor point if needed
  });

  var squareIcon_Old = L.icon({
    iconUrl: 'https://wfrc.org/wftdm-docs/_pictures/square_red.png',       // Replace with the path to your square-like icon image
    iconSize: [15, 15],          // Adjust the size of the square-like icon
    iconAnchor: [5, 5],          // Adjust the anchor point if needed
  });

  var cCommon = "#FF0000"
  var cAdded  = "#00FF00"
  var cOther  = "#888888"

  var geolineCommon = {
      color: cCommon,
      weight: 2,
      opacity: 1,
  };

  var geoLineAdded = {
      color: cAdded,
      weight: 2,
      opacity: 1,
  };
  var geoLineOther = {
      color: cOther,
      weight: 2,
      opacity: 1,
  };
            
  // function to use different icons based on number of stations
  function markerByNewNet(feature) {
    if (feature.properties.FLG_NEWNET==3) {
      return geolineCommon;
    } else if (feature.properties.FLG_NEWNET==23){
      return geoLineAdded;
    } else{
      return geoLineOther;
    }
  };

  function getColor(c) {
    if        (c=='Common') {
      return cCommon;
    } else if (c=='Added') {
      return cAdded;
    } else if (c=='Other') {
      return cOther;
    }
  };

  //let lyrNetwork = L.geoJson(geojsonMasterNetLink, { weight: 0.75, color: "#888888", fillOpacity: 0}).addTo(map);

  // create the GeoJSON layer and call the styling function with each marker
//  var lyrNetwork = L.geoJson(geojsonMasterNetLink,  { function (markerByNewNet(feature))}).addTo(map);

  // create the GeoJSON layer and call the styling function with each marker
  var externalNewLayer = L.geoJSON(geojsonExternalNew, {
    pointToLayer: function (feature, latlng) {
      var mypopup = L.popup().setContent("<b>Node: " + feature.properties.N + "</b>");
      var mymarker = L.marker(latlng, { icon: squareIcon_New });
      mymarker.bindPopup(mypopup);
      return mymarker;
    }
  }).addTo(map);

  // create the GeoJSON layer and call the styling function with each marker
  var externalOldLayer = L.geoJSON(geojsonExternalOld, {
    pointToLayer: function (feature, latlng) {
      var mypopup = L.popup().setContent("<b>Node: " + feature.properties.N + "</b>");
      var mymarker = L.marker(latlng, { icon: squareIcon_Old });
      mymarker.bindPopup(mypopup);
      return mymarker;
    }
  }).addTo(map);

  var legend = L.control({position: 'bottomleft'});
    legend.onAdd = function (map) {
      var div = L.DomUtil.create('div', 'info legend');
      var labelsBill = []; // legend title
      var lcategories = ['v8.3.2','v9.0.0'];
      var lcolors     = [cOld    ,cNew    ];

      for (var i = 0; i < lcategories.length; i++) {
        div.innerHTML += 
          labelsBill.push(
            '<i style="background:' + lcolors[i] + '">&nbsp;</i> ' +
          (lcategories[i] ? lcategories[i] : '+'));
      }
      div.innerHTML = labelsBill.join('<br>');

      // Add CSS style for the background color
      div.style.backgroundColor = 'lightgray';
      div.style.padding = '10px';
      
      return div;
    };
    legend.addTo(map);  
}
```
:::

The updated numbering scheme can be found in @tbl-externals.

<!--![v9 External Description.](_pictures/ex_descrip1.png){#fig-descrip1}

![v8.3.2 External Description.](_pictures/ex_descrip2.png){#fig-descrip2}

![v9 & v8.3.2 External Description.](_pictures/ex_descrip3.png){#fig-descrip3 width='50%'}-->

```{python}
#| label: tbl-externals
#| tbl-cap: v9 & v8.3.2 External Description
#| tbl-colwidths: [10,10,10,40,30]
import pandas as pd
import numpy as np
from IPython.display import Markdown
from tabulate import tabulate
table = pd.read_csv('tables/2-externals.csv')
table['v9Value'] = table['v9Value'].astype(str)
table['v8Value'] =table['v8Value'].astype(str)
table = table.replace(np. nan,'',regex=True) 
headers = ['County','v9 Value','v8 Value', 'Location','Notes']
Markdown(tabulate(table, 
  headers=headers, 
  tablefmt="pipe", 
  colalign=("left",)*len(headers), 
  showindex=False)
)

```

## Segment

The `Master_Segs_withFactors_20220915.shp` file contains the updated segments to align with 2023 RTP network changes. Additional segments for rail transit corridors were added in the Wasatch Front area.
