---
title:  "Version 9.0.0 - What's New?"
date-modified: last-modified
author: "WFRC / MAG"
execute:
    echo: false
---

# Model Results - Comparison with v8.3.2

This section compares the model results between v9.0.0 and v8.3.2 for roadway volumes and transit.

## Road Volume Comparisons

The comparison between daily volumes at the segment level can be found in @fig-volume-comparison for 2019 and 2050. Decreases in volume in v9.0.0 compared to v8.3.2 are shown in blue, while increases are shown in red. Salt Lake and northern Davis counties display a drop in roadway volumes, most apparent on I-15. Weber, southern Davis, and Utah Counties show increases. Most of the changes are relatively minor, with the largest decreases occurring on the freeways in Salt Lake County. However, given the large daily volume for these roadways, the percent change is relatively low.

::: {#fig-volume-comparison layout-ncol=3 .column-screen-inset-right}

![2019](../data/map_pngs/vol19-cropped.png){#fig-vol19}

![2050](../data/map_pngs/vol50-cropped.png){#fig-vol50}

![](../data/map_pngs/vol-legend.png)

Model Daily Volumes Comparison (v9.0 vs v8.3.2)
:::

<mark>???WOULD BE BETTER TO REMOVE LINKS THAT HAVE ZERO LANES, NOTE MUTLIPLE UTAH LAKE CROSSING LINKS IN BOTH 2019 and 2050.</mark>

<mark>???MAY BE GOOD TO INCLUDE TRUCK VOLUME COMPARISON???</mark>


```{python}
import pandas as pd
import plotly as py
import plotly.graph_objects as go
import plotly.express as px 
import ipywidgets as widgets
import numpy as np
from scipy import special
import time
import math as msi
import sys

sys.path.insert(0, '..\..\..\..\..\Resources\Python-Functions')
import BigQuery
 
client = BigQuery.getBigQueryClient_TDMScenarios()
```

```{python}
# include in all scenario groups
lstIncludeInAll = ['BY','TIP']

# dataframe to create subcategories
dfModeGroups = pd.DataFrame([
    ['Walk'     ,'1: Non-Motorized'         ],
    ['Bike'     ,'1: Non-Motorized'         ],
    ['Walk'     ,'1a: Walk'                 ],
    ['Bike'     ,'1b: Bike'                 ],
    ['Auto'     ,'2: Auto'                  ],
    ['SchoolBus','3: SchoolBus'             ],
    ['LCL'      ,'4: Transit'               ],
    ['COR'      ,'4: Transit'               ],
    ['EXP'      ,'4: Transit'               ],
    ['BRT'      ,'4: Transit'               ],
    ['LRT'      ,'4: Transit'               ],
    ['CRT'      ,'4: Transit'               ],
    ['LCL'      ,'4a: Local Bus'            ],
    ['COR'      ,'4b: Core Bus'             ],
    ['EXP'      ,'4c: Express Bus'          ],
    ['BRT'      ,'4d: Bus-Rapid Transit'    ],
    ['LRT'      ,'4e: Light-Rail Transit'   ],
    ['CRT'      ,'4f: Commuter-Rail Transit'],
    ['Walk'     ,'0: Total'                 ],
    ['Bike'     ,'0: Total'                 ],
    ['Auto'     ,'0: Total'                 ],
    ['SchoolBus','0: Total'                 ],
    ['LCL'      ,'0: Total'                 ],
    ['COR'      ,'0: Total'                 ],
    ['EXP'      ,'0: Total'                 ],
    ['BRT'      ,'0: Total'                 ],
    ['LRT'      ,'0: Total'                 ],
    ['CRT'      ,'0: Total'                 ]]
,columns=('MODE','modeGroup'))
#dfModeGroups
```

```{python}
# FILTER
#strSQLWhere = ' WHERE NOT (t.scenarioID = 33)'
strSQLWhere = ''

# merge scenario data onto transit share data

# read transit summary from biq query
dfTransitSummary = client.query("SELECT * FROM tdm-scenarios.tdm_scenarios_output.transit_share AS t" + strSQLWhere).to_dataframe()
#display(dfTransitSummary)

dfRouteSummary = client.query("SELECT * FROM tdm-scenarios.tdm_scenarios_output.route_summary AS t" + strSQLWhere).to_dataframe()
#display(dfRouteSummary)

# read scenarios data biq query
dfScenarios = client.query("SELECT * FROM tdm-scenarios.tdm_scenarios_output.scenarios AS t" + strSQLWhere).to_dataframe()
#display(dfScenarios)

# merge two dataframes
dfTransitSummaryWithScenarioData = pd.DataFrame.merge(dfScenarios,dfTransitSummary,on='scenarioID')
#display(dfTransitSummaryWithScenarioData)

# merge two dataframes
dfRouteSummaryWithScenarioData = pd.DataFrame.merge(dfScenarios,dfRouteSummary,on='scenarioID')
#display(dfTransitSummaryWithScenarioData)

# merge to mode groupings dataframe
dfTransitSummaryPlotData = pd.DataFrame.merge(dfTransitSummaryWithScenarioData,dfModeGroups,on='MODE')
#dfTransitSummaryPlotData
```

```{python}
#Transit Ridership Plotting Function

import math

def update_plot(tdmVersionsWithDate, scenarioGroups, modeGroups, trippurps, periods):

    data = []

    for v in tdmVersionsWithDate:
        for g in scenarioGroups:
            for m in modeGroups:

                # only do if data in dataframe since BY data is concatonated later
                if dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==v) & (dfTransitSummaryPlotData['scenarioGroup'].isin([g])) & (dfTransitSummaryPlotData['modeGroup']==m) & (dfTransitSummaryPlotData['TRIPPURP'].isin(trippurps)) & (dfTransitSummaryPlotData['PERIOD'].isin(periods))].shape[0]>1:

                    # data for plotting from filtered dataframe}
                    plotdata = dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==v) & (dfTransitSummaryPlotData['scenarioGroup'].isin(lstIncludeInAll + [g])) & (dfTransitSummaryPlotData['modeGroup']==m) & (dfTransitSummaryPlotData['TRIPPURP'].isin(trippurps)) & (dfTransitSummaryPlotData['PERIOD'].isin(periods))]

                    #display(plotdata)

                    plotdata = plotdata.groupby(['scenarioYear'], as_index=False).agg(TRIPS=('TRIPS','sum'))

                    # fill any NaN values with zeros
                    plotdata = plotdata.fillna(0)

                    #display(plotdata)

                    xplot = plotdata['scenarioYear']
                    yplot = plotdata['TRIPS'       ]

                    trace1 = go.Scatter(
                        x=xplot,
                        y=yplot,
                        mode='markers+lines',
                        name= v + ' ' + g + ' ' + m,
                        marker=dict(size=12,
                                line=dict(width=2,
                                            color='DarkSlateGrey'))#,
                        #stackgroup='one',
                        #groupnorm='percent' # sets the normalization for the sum of the stackgroup
        #                line=dict(
        #                    shape='spline'
        #                )
                    )
                    data.append(trace1)


    layout = go.Layout(
        #title='Trips by Mode (' + '/'.join(trippurps) + ' ' + '/'.join(periods) + ')',
        yaxis=dict(
            title='Trips',
            rangemode = 'tozero'#,
            #range=(0,np.null)
        ),
        xaxis=dict(
            title='Year',
            range=(2018,2051)
        ),
        width=800,
        height=550
    )
    
    fig = go.Figure(data=data, layout=layout)
    fig.update_layout(legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01
    ))
    py.offline.iplot(fig)
py.offline.init_notebook_mode(connected=True)
```

```{python}
#Transit Share Plotting Function

import math

def update_plot_stackedarea(tdmVersionWithDate, scenarioGroup, modeGroups, trippurps, periods):

    data = []

    modeGroups = sorted(modeGroups)

    for m in modeGroups: 
        # only do if data in dataframe since BY data is concatonated later
        if dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==tdmVersionWithDate) &
                                    (dfTransitSummaryPlotData['scenarioGroup'     ]==scenarioGroup     ) &
                                    (dfTransitSummaryPlotData['modeGroup'         ]==m                 ) &
                                    (dfTransitSummaryPlotData['TRIPPURP'          ].isin(trippurps)    ) &
                                    (dfTransitSummaryPlotData['PERIOD'            ].isin(periods)      )].shape[0]>1:

            # data for plotting from filtered dataframe}
            plotdata = dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==tdmVersionWithDate                    ) &
                                                (dfTransitSummaryPlotData['scenarioGroup'     ].isin(lstIncludeInAll + [scenarioGroup])) &
                                                (dfTransitSummaryPlotData['modeGroup'         ]==m                                     ) &
                                                (dfTransitSummaryPlotData['TRIPPURP'          ].isin(trippurps)                        ) &
                                                (dfTransitSummaryPlotData['PERIOD'            ].isin(periods)                          )]

            #display(plotdata)

            plotdata = plotdata.groupby(['scenarioYear'], as_index=False).agg(TRIPS=('TRIPS','sum'))

            # fill any NaN values with zeros
            plotdata = plotdata.fillna(0)

            #display(plotdata)

            xplot = plotdata['scenarioYear']
            yplot = plotdata['TRIPS'       ]

            trace1 = go.Scatter(
                x=xplot,
                y=yplot,
                mode='lines',
                name= m,
                stackgroup='one',
                groupnorm='percent' # sets the normalization for the sum of the stackgroup
            )
            data.append(trace1)


    layout = go.Layout(
        #title=tdmVersionWithDate + ' Trips Mode Split (' + '/'.join(trippurps) + ' ' + '/'.join(periods) + ')',
        yaxis=dict(
            title='Percent of Total Trips'#,
            #rangemode = 'tozero',
            #ticksuffix='%',
            #range=(0,100)
        ),
        xaxis=dict(
            title='Year'#,
            #range=(2018,2051)
        ),
        width=950,
        height=400
    )
    
    fig2 = go.Figure(data=data, layout=layout)
    py.offline.iplot(fig2)
py.offline.init_notebook_mode(connected=True)
```

```{python}
#PLOTTING FUNCTION

import math

def update_plot_stackedarea_boardings(tdmVersionWithDate, scenarioGroup):

    data = []

    modes = sorted(dfRouteSummaryWithScenarioData['MODE'].unique())

    for m in modes: 
        # only do if data in dataframe since BY data is concatonated later
        if dfRouteSummaryWithScenarioData[(dfRouteSummaryWithScenarioData['tdmVersionWithDate']==tdmVersionWithDate) &
                                          (dfRouteSummaryWithScenarioData['scenarioGroup'     ]==scenarioGroup     ) &
                                          (dfRouteSummaryWithScenarioData['MODE'              ]==m                 )].shape[0]>1:

            # data for plotting from filtered dataframe}
            plotdata = dfRouteSummaryWithScenarioData[(dfRouteSummaryWithScenarioData['tdmVersionWithDate']==tdmVersionWithDate                    ) &
                                                      (dfRouteSummaryWithScenarioData['scenarioGroup'     ].isin(lstIncludeInAll + [scenarioGroup])) &
                                                      (dfRouteSummaryWithScenarioData['MODE'              ]==m                                     )]

            #display(plotdata)

            plotdata = plotdata.groupby(['scenarioYear'], as_index=False).agg(BOARDINGS=('DY_BRDA','sum'))

            # fill any NaN values with zeros
            plotdata = plotdata.fillna(0)

            #display(plotdata)

            xplot = plotdata['scenarioYear']
            yplot = plotdata['BOARDINGS'   ]

            trace1 = go.Scatter(
                x=xplot,
                y=yplot,
                mode='lines',
                name= 'Mode ' + str(m),
                stackgroup='one',
                groupnorm='percent' # sets the normalization for the sum of the stackgroup
            )
            data.append(trace1)


    layout = go.Layout(
        #title=tdmVersionWithDate + ' Boardings by Mode',
        yaxis=dict(
            title='Percent of Total Boardings'#,
            #rangemode = 'tozero',
            #ticksuffix='%',
            #range=(0,100)
        ),
        xaxis=dict(
            title='Year'#,
            #range=(2018,2051)
        ),
        width=840,
        height=400
    )
    
    fig2 = go.Figure(data=data, layout=layout)
    py.offline.iplot(fig2)
py.offline.init_notebook_mode(connected=True)
```
## Transit Comparisons

Transit comparisons were done with ridership, trips mode share, and boardings mode share. Overall ridership increases significantly in v9.0.0, and Core Bus ridership takes a larger share of trips and boardings than in v8.3.2.

### Transit Ridership

Transit ridership in v9.0.0 compared to v8.3.2 shows significant increase in 2032, 2042, and 2050. See @fig-hy-tr-all. The total ridership in 2050 for v9.0.0 is 332,000 daily trips compared to the v8.3.2 model that showed 258,000 daily trips, which represents a 29% increase. The increase is largely due to the improvements in commuter rail with increased frequency and speed. <mark>???VERIFY!!???</mark>

```{python}
#| label: fig-hy-tr-all
#| fig-cap: "Daily Transit Ridership - All Purposes"
#| cap-location: margin
#| column: screen-inset-right

update_plot(
    ['WF TDM v8.3.2 - 2022-02-04a', 'WF TDM v9.0 - 2023-04-28'], 
    ['RTP'], 
    ['4: Transit'], 
    ['HBC', 'HBO', 'HBS', 'HBW', 'NHB'], 
    ['Pk','Ok']
)
```

<mark>???NEED TO GET RID OF DATE TIME STAMP AND OTHER 'CODE'S IN MODEL LEGEND "Transit" instead of "4: Transit"???</mark>

For Home-Based College (HBC) trips, the v9.0.0 model shows lower projections. See @fig-dy-tr-hbc. This is mostly due to many of the lower enrollment colleges being removed from the trips tables. The uptick in HBC trips in 2042 and 2050 in v9.0.0 follow similar increases the updated enrollment trends. <mark>???ADD REFERENCE TO COLLEGES SECTION IN INPUTS???</mark>

```{python}
#| label: fig-dy-tr-hbc
#| fig-cap: "Daily Transit Ridership - Home-Based College"
#| cap-location: margin
#| column: screen-inset-right

update_plot(
    ['WF TDM v8.3.2 - 2022-02-04a','WF TDM v9.0 - 2023-04-28'], 
    ['RTP'], 
    ['4: Transit'], 
    ['HBC'], 
    ['Pk','Ok']
)
```


### Transit Share

A comparison of the share of trips amongst the various modes of transit was done for both Trips and Boardings.

#### Trips

The transit ridership trip shares by mode can be found in @fig-shr-tr-all-9 for v9.0.0 and @fig-shr-tr-all-832 for v8.3.2. The main difference in v9.0.0 trip share by mode is the large increase in Core Bus trips in 2032 from almost nothing in 2028, while in v8.3.2 the increase in Core Bus trips is spread out between 2024 and 2030. This large increase is consistent with the transit inputs into the model with a large number of Core Bus routes coming into production in 2032, replacing mostly local bus service. The new Core Buy takes most of the local bus ridership it is replacing, but also quite a lot of ridership from Light Rail Transit (Mode 7).


<mark>???MAP SHOWING TRANSIT CHANGES, LIKE ROADWAY VOLUMES WOULD BE USEFUL???</mark>

```{python}
#| label: fig-shr-tr-all-9
#| fig-cap: "Transit Trips Share by Mode - v9.0"
#| cap-location: margin
#| column: screen-inset-right

update_plot_stackedarea(
    'WF TDM v9.0 - 2022-12-19', 
    'RTP', 
    ['4a: Local Bus','4b: Core Bus','4c: Express Bus','4d: Bus-Rapid Transit','4e: Light-Rail Transit','4f: Commuter-Rail Transit'], 
    ['HBC', 'HBO', 'HBS', 'HBW', 'NHB'], 
    ['Pk','Ok']
)
```

```{python}
#| label: fig-shr-tr-all-832
#| fig-cap: "Transit Trips Share by Mode - v8.3.2"
#| cap-location: margin
#| column: screen-inset-right

update_plot_stackedarea(
    'WF TDM v8.3.2 - 2022-02-04a', 
    'RTP', 
    ['4a: Local Bus','4b: Core Bus','4c: Express Bus','4d: Bus-Rapid Transit','4e: Light-Rail Transit','4f: Commuter-Rail Transit'], 
    ['HBC', 'HBO', 'HBS', 'HBW', 'NHB'], 
    ['Pk','Ok']
)
```

<mark>???ANYWAY TO GET THESE CHARTS SIDE-BY-SIDE... ALSO LOT OF WHITE SPACE BETWEEN CHART AND CAPTION, WHICH MAKES IT A LITTLE CONFUSING???</mark>


### Transit Boardings

Transit boardings for v9.0.0 are found in @fig-brd-9 and for v8.3.2 are found in @fig-brd-832. Boardings follow the same pattern as trips, but boardings are able to differentiate between modes better than trips that are categorized hierarchically.


```{python}
#| label: fig-brd-9
#| fig-cap: "Transit Boardings Share by Mode - v9.0"
#| cap-location: margin
#| column: screen-inset-right

update_plot_stackedarea_boardings('WF TDM v9.0 - 2022-12-19', 'RTP')
```

```{python}
#| label: fig-brd-832
#| fig-cap: "Transit Boardings Share by Mode - v8.3.2"
#| cap-location: margin
#| column: screen-inset-right

update_plot_stackedarea_boardings('WF TDM v8.3.2 - 2022-02-04a', 'RTP')
```

<mark>???SAME COMMENTS FOR THESE TWO AS THE TWO ABOVE???</mark>

## Commuter Rail Station Boardings

The comparison of base year (2019) station-level boardings for commuter-rail transit (CRT) is found in @fig-fr-brd. CRT boardings were found to be higher than observed for Davis County and lower than observed for Utah County. An adjustment of 5 additional minutes to in-vehicle-time for trips to/from Davis County and 5 fewer minute to in-vehicle-time for Utah County was made to attempt to bring the model more in-line with observations. <mark>???VERIFY!!!???</mark>

Additional investigation was conducted into why Provo and Lehi were particularly low in the model. The findings did not turn up any obvious errors in the transit or model network. So, the conclusion is that further adjustments to CRT will be possible in the Mode Choice Update project that is currently being undertaken for the next release of the model.


```{python}
#| label: fig-fr-brd
#| fig-cap: "2019 Daily CRT Boardings by Station - Model vs Observed "
#| cap-location: margin
#| column: screen-inset-right

boardings_barchart = pd.read_csv(r'..\data\frontrunner-summary-comparison-v832-v9.csv')
import plotly.express as px
df = px.data.tips()
fig = px.histogram(boardings_barchart, x="Stop_Name", y="Boardings", text_auto='.2s',
             color='Model_Name', barmode='group',
             height=400)
fig.update_layout(
    xaxis_title="Station Name",
    yaxis_title="Average Boardings",
    legend_title="Model Version"
)
#fig.update_xaxes(tickangle=90)
fig.show()
```