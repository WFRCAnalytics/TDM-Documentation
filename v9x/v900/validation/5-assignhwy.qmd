---
title: Highway Assignment
echo: false
warning: false
message: false
---


The validation results for the Highway Assignment portion of the model are shown in this section.The observed data for 2019 volumes is taken from the Utah Department of Transportation (UDOT) [Average Annual Daily Traffic (AADT) History](https://drive.google.com/file/d/1rDXm0ObugGR1zXgWUuVbzWHNt-Xs1xru/view) and associated with their respective model segments. The traffic model data is taken from segment summary report for the 2019 base year model: `v9_SE19_Net19_Summary_SEGID.csv`. The results are divided into three sections:

- Summary Comparison
- Detailed Comparison
- Map Comparison

```{ojs}
import {GroupedBarChart} from "@d3/grouped-bar-chart"
import {Legend, Swatches} from "@d3/color-legend"
import {howto, altplot} from "@d3/example-components"
```
```{python}
import pandas as pd
import numpy as np
```

```{python}
allveh_valid = pd.read_csv("data/5-assignhwy/wf-validation-06-30-2023-AllVeh.csv")

allveh = allveh_valid[['SEGID','CO_FIPS','DISTANCE','Valid_FC',
                       'Mod_AWDT', 'Obs_AWDT', 
                       'Mod_Car' , 'Obs_Car' ,
                       'Mod_MD'  , 'Obs_MD'  ,
                       'Mod_HV'  , 'Obs_HV'  ]].copy()

allveh.rename(columns={'Valid_FC':'funcClass'}, inplace=True)

# create a copy for 'All Roadways' category
_allfc = allveh.copy()
_allfc['funcClass'] = 'All Roadways'

allveh = pd.concat([allveh,_allfc])

# manually 'melt' veh type
_dfPC = allveh[['SEGID', 'DISTANCE', 'CO_FIPS', 'funcClass', 'Mod_Car' ,'Obs_Car' ]].rename(columns={'Mod_Car' :'volMod', 'Obs_Car' :'volObs', 'CO_FIPS':'coFips'})
_dfMD = allveh[['SEGID', 'DISTANCE', 'CO_FIPS', 'funcClass', 'Mod_MD'  ,'Obs_MD'  ]].rename(columns={'Mod_MD'  :'volMod', 'Obs_MD'  :'volObs', 'CO_FIPS':'coFips'})
_dfHV = allveh[['SEGID', 'DISTANCE', 'CO_FIPS', 'funcClass', 'Mod_HV'  ,'Obs_HV'  ]].rename(columns={'Mod_HV'  :'volMod', 'Obs_HV'  :'volObs', 'CO_FIPS':'coFips'})
_dfAl = allveh[['SEGID', 'DISTANCE', 'CO_FIPS', 'funcClass', 'Mod_AWDT','Obs_AWDT']].rename(columns={'Mod_AWDT':'volMod', 'Obs_AWDT':'volObs', 'CO_FIPS':'coFips'})

# add vehicle types
_dfPC['vehType'] = 'Passenger Cars'
_dfMD['vehType'] = 'Medium Trucks'
_dfHV['vehType'] = 'Heavy Trucks'
_dfAl['vehType'] = 'All Vehicles'

# combine
allveh = pd.concat([_dfPC, _dfMD, _dfHV, _dfAl])

# calc diffSquare
allveh['volDiffSq'  ] = (allveh['volMod'] - allveh['volObs']) ** 2 #squared
allveh['volErrorPct'] = (allveh['volMod'] - allveh['volObs']) / allveh['volObs']

# recalc VMT
allveh['vmtMod'] = allveh['volMod'] * allveh['DISTANCE']
allveh['vmtObs'] = allveh['volObs'] * allveh['DISTANCE']

# remove nulls
allveh.dropna(inplace=True)
#allvehfc

allveh2 = allveh.copy()
allveh2['coFips'] = 'Region'
allveh = pd.concat([allveh, allveh2])
#allveh
```

```{python}
agg_functions = {'SEGID'     : 'count',
                 'volMod'    : 'mean',
                 'volObs'    : 'mean',
                 'volDiffSq' : lambda x: np.sqrt(np.sum(x) / (x.nunique() - 1)),# this is right, excel is wrong (excel is only using sum at county level)
                 'vmtMod'    : 'sum',
                 'vmtObs'    : 'sum'} 

#summarize allveh to create daily comparison by coFips, funcClass, vehType tables
allveh_sum = allveh.groupby(['coFips','funcClass','vehType']).agg(agg_functions).reset_index()
allveh_sum = allveh_sum.rename(columns={'SEGID':'numSegs','volDiffSq':'volRmse'})

allveh_sum['volDiff'   ] = allveh_sum['volMod'] - allveh_sum['volObs']
allveh_sum['vmtDiff'   ] = allveh_sum['vmtMod'] - allveh_sum['vmtObs']

allveh_sum['volDiffPct'] = allveh_sum['volDiff'] / allveh_sum['volObs']
allveh_sum['vmtDiffPct'] = allveh_sum['vmtDiff'] / allveh_sum['vmtObs']

allveh_sum['volRmsePct'   ] = (allveh_sum['volRmse'] / allveh_sum['volObs'])

allveh_sum_copy = allveh_sum.copy()
#allveh_sum_copy
```

```{python}
allveh_vol = allveh_sum[['coFips','funcClass','vehType','numSegs','volMod','volObs','volDiff','volDiffPct','volRmse','volRmsePct']]
allveh_vmt = allveh_sum[['coFips','funcClass','vehType','numSegs','vmtMod','vmtObs','vmtDiff','vmtDiffPct']]
```

```{python}
allveh_pct = allveh_sum[['coFips','funcClass','vehType','volDiffPct','vmtDiffPct']]
allveh_pct = allveh_pct.melt(id_vars=['coFips','funcClass','vehType'], value_vars=['volDiffPct','vmtDiffPct'], var_name='Variable', value_name='Value')
allveh_pct = allveh_pct.pivot(index=['funcClass','vehType','Variable'], columns='coFips', values='Value').reset_index()
allveh_pct = allveh_pct[['Variable', 'funcClass','vehType', 'Region', 3, 57, 11, 35, 49]]
```

```{python}
allveh_pct_exact = allveh_sum_copy[['coFips','funcClass','vehType','volDiffPct','vmtDiffPct']]
allveh_pct_exact = allveh_pct_exact.melt(id_vars=['coFips','funcClass','vehType'], value_vars=['volDiffPct','vmtDiffPct'], var_name='Variable', value_name='Value')
allveh_pct_exact = allveh_pct_exact.pivot(index=['funcClass','vehType','Variable'], columns='coFips', values='Value').reset_index()
allveh_pct_exact = allveh_pct_exact[['Variable','funcClass','vehType','Region',3,57,11,35,49]]
allveh_pct_exact = allveh_pct_exact.melt(id_vars = ['funcClass','vehType', 'Variable'], value_vars = ['Region',3,57,11,35,49], value_name='Value', var_name='Region')
```

```{python}
allveh_abs_exact = allveh_sum_copy[['coFips', 'funcClass', 'volMod', 'volObs', 'vmtMod', 'vmtObs']]
allveh_abs_exact = allveh_abs_exact.melt(id_vars = ['coFips','funcClass'], value_vars = ['volMod', 'volObs', 'vmtMod', 'vmtObs'], var_name = 'DataSource',value_name = 'Value')
allveh_abs_exact['Variable'] = allveh_abs_exact['DataSource'].apply(lambda x: 'Volume' if 'Volume' in x else 'VMT')
allveh_abs_exact['DataSource'] = allveh_abs_exact['DataSource'].apply(lambda x: 'Model' if 'Model' in x else 'Observed')
allveh_abs_region = allveh_abs_exact[allveh_abs_exact['coFips'] == 'Region']
```

```{python}
allveh_vol_long = allveh_vol.rename(columns={'volMod':'Model','volObs':'Observed'})
allveh_vol_long = pd.melt(allveh_vol_long,
                          id_vars =['coFips','funcClass','vehType'],
                          value_vars = ['Model', 'Observed'],
                          var_name = 'DataSource',
                          value_name = 'ViewValue')
allveh_vol_long['ViewValue'] = allveh_vol_long['ViewValue'] / 1000
allveh_vmt_long = allveh_vmt.rename(columns={'vmtMod':'Model','vmtObs':'Observed'})
allveh_vmt_long = pd.melt(allveh_vmt_long,
                          id_vars =['coFips','funcClass','vehType'],
                          value_vars = ['Model', 'Observed'],
                          var_name = 'DataSource',
                          value_name = 'ViewValue')     
allveh_vmt_long['ViewValue'] = allveh_vmt_long['ViewValue'] / 1000000


# summary chart

allveh_vol_diff_long = pd.melt(allveh_vol,
                               id_vars =['coFips','funcClass','vehType'],
                               value_vars = ['volDiff', 'volDiffPct'],
                               var_name = 'View',
                               value_name = 'ViewValue')


allveh_vmt_diff_long = pd.melt(allveh_vmt,
                               id_vars =['coFips','funcClass','vehType'],
                               value_vars = ['vmtDiff', 'vmtDiffPct'],
                               var_name = 'View',
                               value_name = 'ViewValue')

# Create a mapping dictionary for the coFips values
fips_mapping = {
    3: 'Box Elder County - WFRC',
    11: 'Davis County',
    35: 'Salt Lake County',
    49: 'Utah County',
    57: 'Weber County - WFRC'
}
# Use the `replace` method on the 'coFips' column
allveh_vol_diff_long['coFips'] = allveh_vol_diff_long['coFips'].replace(fips_mapping)
allveh_vmt_diff_long['coFips'] = allveh_vmt_diff_long['coFips'].replace(fips_mapping)

import math

def round_up_to_next_significant(value):
    if value == 0:
        return 0
    magnitude = 10 ** math.floor(math.log10(value))
    return math.ceil(value / magnitude) * magnitude

max_abs_value_volDiff    = round_up_to_next_significant(allveh_vol_diff_long.query("View == 'volDiff'"   )['ViewValue'].abs().max())
max_abs_value_vmtDiff    = round_up_to_next_significant(allveh_vmt_diff_long.query("View == 'vmtDiff'"   )['ViewValue'].abs().max())
max_abs_value_volDiffPct = round_up_to_next_significant(allveh_vol_diff_long.query("View == 'volDiffPct'")['ViewValue'].abs().max())
max_abs_value_vmtDiffPct = round_up_to_next_significant(allveh_vmt_diff_long.query("View == 'vmtDiffPct'")['ViewValue'].abs().max())

# scatter plot dataframe
allvehplot = allveh[['SEGID','coFips','funcClass','vehType','volMod','volObs','volErrorPct']].copy()
allvehplot['volMod'] = allvehplot['volMod'] / 1000 # reduce so axis labels are shorter
allvehplot['volObs'] = allvehplot['volObs'] / 1000 # reduce so axis labels are shorter
```

```{python}
# save as ojs objects

# for summary comparison
ojs_define(volDiffLong = allveh_vol_diff_long) 
ojs_define(vmtDiffLong = allveh_vmt_diff_long)

# for detailed comparison
ojs_define(vol = allveh_vol) 
ojs_define(vmt = allveh_vmt)
ojs_define(volLong = allveh_vol_long)
ojs_define(vmtLong = allveh_vmt_long)
ojs_define(allvehplot = allvehplot) # for scatter plot

# use?
ojs_define(vvpct = allveh_pct)
ojs_define(vvpctLong = allveh_pct_exact)
ojs_define(vvabsLong = allveh_abs_exact)
ojs_define(vvabsLongR = allveh_abs_region)

ojs_define(max_abs_value_volDiff    = max_abs_value_volDiff   )
ojs_define(max_abs_value_vmtDiff    = max_abs_value_vmtDiff   )
ojs_define(max_abs_value_volDiffPct = max_abs_value_volDiffPct)
ojs_define(max_abs_value_vmtDiffPct = max_abs_value_vmtDiffPct)


```

## Summary Comparison

The summary comparison shows region and county-wide differences between model and observed for *Average Daily Volume* and *Vehicle-Miles Traveled (VMT)* by vehicle type. The values for Box Elder and Weber counties are only the portions within the MPO planning area. Validation was checked comparing the average daily volume at the region and county levels. @fig-assign-summary, below, contains an interactive view of model vs observed differences by roadway class and vehicle type.

```{ojs}
html`<br/>`
viewof bSummaryFuncClass = Inputs.select(new Map([['All Roadways','All Roadways'], ['Freeway','Freeway'], ['Principal','Principal'], ['Minor', 'Minor'], ['Collector', 'Collector']]), {value: 'All Roadways', label: "Roadway Class:"})
viewof bSummaryVehType = Inputs.select(new Map([['All Vehicles','All Vehicles'], ['Passenger Cars', 'Passenger Cars'], ['Medium Trucks','Medium Trucks'], ['Heavy Trucks','Heavy Trucks']]), {value: 'All Vehicles', label: "Vehicle Type:"})
viewof bSummaryDiffType = Inputs.select(new Map([['Percent Difference','DiffPct'], ['Difference','Diff']]), {value: 'DiffPct', label: "Display:"})
```

```{ojs}

volDiffLongT = transpose(volDiffLong)
vmtDiffLongT = transpose(vmtDiffLong)

volDiffLongT_filtered = volDiffLongT.filter(function(dataL) {
    return bSummaryFuncClass == dataL.funcClass &&
           bSummaryVehType == dataL.vehType &&
           (('vol' + bSummaryDiffType) == dataL.View);
})
vmtDiffLongT_filtered = vmtDiffLongT.filter(function(dataL) {
    return bSummaryFuncClass == dataL.funcClass &&
           bSummaryVehType == dataL.vehType &&
           (('vmt' + bSummaryDiffType) == dataL.View);
})

vvp = transpose(vvpct)
vvpL = transpose(vvpctLong)
vvaL = transpose(vvabsLong)
vvaLR = transpose(vvabsLongR)
```


```{ojs}
//https://observablehq.com/@d3/diverging-bar-chart
import {DivergingBarChart} from "@d3/diverging-bar-chart"

function getXDomainVol(bSummaryDiffType) {
    if (bSummaryDiffType === "Diff") {
        return [max_abs_value_volDiff * -1, max_abs_value_volDiff];
    } else {
        return [max_abs_value_volDiffPct * -1, max_abs_value_volDiff]; // -100% to 100%
    }
}

function getXDomainVmt(bSummaryDiffType) {
    if (bSummaryDiffType === "Diff") {
        return [max_abs_value_vmtDiff * -1, max_abs_value_vmtDiff];
    } else {
        return [max_abs_value_vmtDiffPct * -1, max_abs_value_vmtDiff]; // -100% to 100%
    }
}
```

:::: {.columns}
::: {.column width="50%"}

```{ojs}
html`<br/><h4>Average Daily Volume</h4>`
chartVolDiff = DivergingBarChart(volDiffLongT_filtered, {
    x: d => d.ViewValue,
    y: d => d.coFips,
    xFormat: bSummaryDiffType === "Diff" ? "+,d" : "+.1%",
    xLabel: "Model vs Observed Differences",
    width: 440,
    xDomain: bSummaryDiffType === "Diff" ? [max_abs_value_volDiff * -1, max_abs_value_volDiff] : [max_abs_value_volDiffPct * -1, max_abs_value_volDiffPct],
    yDomain:  ['Region','Box Elder County - WFRC','Weber County - WFRC','Davis County','Salt Lake County','Utah County'],
    colors: d3.schemeRdBu[3]
})
```

:::
::: {.column width="50%"}

```{ojs}
html`<br/><h4>Vehicle-Miles Traveled</h4>`
chartVmtDiff = DivergingBarChart(vmtDiffLongT_filtered, {
    x: d => d.ViewValue,
    y: d => d.coFips,
    xFormat: bSummaryDiffType === "Diff" ? "+,d" : "+.1%",
    xLabel: "Model vs Observed Differences",
    width: 440,
    xDomain: bSummaryDiffType === "Diff" ? [max_abs_value_vmtDiff * -1, max_abs_value_vmtDiff] : [max_abs_value_vmtDiffPct * -1, max_abs_value_vmtDiffPct],
    yDomain:  ['Region','Box Elder County - WFRC','Weber County - WFRC','Davis County','Salt Lake County','Utah County'],
    colors: d3.schemeRdBu[3]
})
```

:::
::::


```{ojs}
//|label: fig-assign-summary
//|fig-cap: Highway Assignment Summary Comparison
tbEmptyCell1 = 1
```


At the region level model volume is 0.2% lower than observed volume. The four more urban counties (Weber, Davis, Salt Lake, and Davis) were all within 5% of observed volumes with Salt Lake County being the closest. Weber and Davis were slightly lower and Utah County was slightly higher. Box Elder County is more rural than the other counties. Box Elder model volumes are about 10% lower than observed. Time did not allow for further calibration of the volumes in Box Elder area to account for the larger differences.

One important observation at the *Collector* and *All Vehicles* level is that Utah County shows a much higher difference than the other counties. Upon further investigation of observed *Collector* volumes in Utah County, many roadway segments had very low volumes compared to what was expected. Utah County is one of the highest growth areas in the region. For this reason, we expect that the observed count data may be underrepresenting actual volumes. We also anticipate observed volumes in Utah County to improve in the near-term. Within the last several years, a large investment in continuous count station in Utah County has been made. The new counters will add additional information to generate observed volumes for all roadway segments.

The largest differences in model vs observed volumes occur in the Medium Truck and Heavy Truck vehicle types. A good amount of time was spent attempting to bring model truck volumes closer to observed. However, due to the limited data sources for truck information, further need to investigate observed truck volumes, and a desire to not over-calibrate the model, further calibration was stopped. Truck modeling remains a future priority for model improvement.


## Detailed Comparison

The model vs observed details in this section are presented by volume and Vehicle-Miles Traveled (VMT) through the comparison of model and observed data facility type by region and also by county. @fig-assign-validation allows for the interactive visual comparison of model and observed values for the region and each county for all vehicles, cars, medium trucks, and heavy trucks. The comparisons are shown in four different types of charts and tables:

- *Average Daily Volume by Roadway Class (2a)*: The daily volume is averaged across all segments within their respective geography and vehicle type.
- *Total VMT by Roadway Class (2b)*: For each segment*, the daily volume is multiplied by segment distance and then summed across all segments within their respective geography and vehicle type.
- *Model vs Count Segment Volume (2c)*: This is a scatter plot of segment daily volume with the x-axis as the observed volume and the y-axis as the model volume. The red line shows the location of where model and observed volumes are equal. The dashed blue line shows a least-squares linear regression. The further the blue line moved away from the red line, the further the model is from observed.
- *Segment Percent Error (2d)*: This is a scatter plot showing the amount of error (percent difference) between the observed volume and the model volume. The observed volume is the x-axis and the percent error is the y-axis. The red lines are a bounding box that shows the control target. As volume increases, it is expected that the percent error should decrease.


::: {.content-visible when-format="html"}

```{ojs}
html`<br/>`
viewof bCountySelect = Inputs.select(new Map([['Region', 'Region'], ['Box Elder County - WFRC',3], ['Weber County - WFRC',57], ['Davis County',11], ['Salt Lake County',35], ['Utah County',49]]), {value: 'All', label: "Geography:"})
viewof bVehType = Inputs.select(new Map([['All Vehicles','All Vehicles'], ['Passenger Cars', 'Passenger Cars'], ['Medium Trucks','Medium Trucks'], ['Heavy Trucks','Heavy Trucks']]), {value: 'All Vehicles', label: "Vehicle Type:"})

sortOrder = ['Freeway', 'Principal', 'Minor', 'Collector', 'All Roadways'];

volT = transpose(vol)
vmtT = transpose(vmt)
filtered_volData = volT.filter(function(dataL) {
    return bCountySelect == dataL.coFips &&
           bVehType == dataL.vehType;
}).sort((a, b) => sortOrder.indexOf(a.funcClass) - sortOrder.indexOf(b.funcClass));
filtered_vmtData = vmtT.filter(function(dataL){
    return bCountySelect == dataL.coFips &&
           bVehType == dataL.vehType;
}).sort((a, b) => sortOrder.indexOf(a.funcClass) - sortOrder.indexOf(b.funcClass));

volTL = transpose(volLong)
vmtTL = transpose(vmtLong)
filtered_volDataL = volTL.filter(function(dataL) {
    return bCountySelect == dataL.coFips &&
           bVehType == dataL.vehType;
}).sort((a, b) => sortOrder.indexOf(a.funcClass) - sortOrder.indexOf(b.funcClass));
filtered_vmtDataL = vmtTL.filter(function(dataL){
    return bCountySelect == dataL.coFips &&
           bVehType == dataL.vehType;
}).sort((a, b) => sortOrder.indexOf(a.funcClass) - sortOrder.indexOf(b.funcClass));


allvehplotT = transpose(allvehplot)
filtered_allvehplotData = allvehplotT.filter(function(dataL) {
    return bCountySelect == dataL.coFips &&
           bVehType == dataL.vehType;
});

```


:::: {.columns}
::: {.column width="65%"}

```{ojs}
//| echo: false
function formatNumber(value, isPercentage=false) {
    if (typeof value === 'undefined') {
        return '';  // or return a default value or message
    }
    
    if (isPercentage) {
        return (Number(value) * 100).toFixed(1) + '%';
    }
    return Number(value.toFixed(0)).toLocaleString();
}

widthsVol = ['100px', '52px', '70px', '70px', '73px', '73px', '63px', '63px']; // Define the widths
widthsVmt = ['100px', '88px', '88px', '88px', '88px']; // Define the widths
```

```{ojs}
//| echo: false
html`
<h4>2a. Average Daily Volume by Roadway Class</h4>
<table>
    <thead>
    <tr>
        ${["Roadway Class", "# Segs", "Volume", "Observed", "Difference", "Percent Difference", "RMSE", "Percent RMSE"].map((d, i) => {
            return html`<th style='text-align: ${i === 0 ? "left" : "right"}; padding: 5px; width: ${widthsVol[i]};'>${d}</th>`;
        })}
    </tr>
    </thead>
    <tbody>
        ${filtered_volData.map(row => {
            const isBold = row['funcClass'] === 'All Roadways';
            return html`<tr style='border-bottom: 1px solid lightgrey;'>
                ${["funcClass", "numSegs", "volMod", "volObs", "volDiff", "volDiffPct", "volRmse", "volRmsePct"].map((d, i) => {
                    // Check if the current cell is one of the numeric columns that need formatting
                    let formattedValue;
                    if (i === 5 || i === 7) {
                        formattedValue = formatNumber(row[d], true);  // True for percentage formatting
                    } else if ((i >= 1 && i <= 4) || i==6) {
                        formattedValue = formatNumber(row[d]);
                    } else {
                        formattedValue = row[d];
                    }
                    return html`<td style='text-align: ${i === 0 ? "left" : "right"}; padding: 5px; font-weight: ${isBold ? 'bold' : 'normal'};'>${formattedValue}</td>`;
                })}
            </tr>`;
        })}
    </tbody>
</table>`
```

:::
::: {.column width="35%"}

```{ojs}
html`<h4>&nbsp;</h4>`
keyVol = Legend(bChartVol.scales.color, {title: "Data Source"})

bChartVol = GroupedBarChart(filtered_volDataL, {
    x: d => d.funcClass,
    y: d => d.ViewValue,
    z: d => d.DataSource,
    xDomain: ['Freeway','Principal','Minor','Collector','All Roadways'],
    yLabel: "Volume (thousands)",
    zDomain: ['Model','Observed'],
    width: 320,
    height: 175,
    colors: ["#376092", "#77933c"]
})
```

:::
::::

:::: {.columns}
::: {.column width="65%"}

```{ojs}
html`
<h4>2b. Total Daily VMT by Roadway Class</h4>
<table>
    <thead>
    <tr>
        ${["Roadway Class", "Model", "Observed", "Difference", "Percent Difference"].map((d, i) => {
            return html`<th style='text-align: ${i === 0 ? "left" : "right"}; padding: 5px; width: ${widthsVmt[i]};'>${d}</th>`;
        })}
    </tr>
    </thead>
    <tbody>
        ${filtered_vmtData.map(row => {
            const isBold = row['funcClass'] === 'All Roadways';
            return html`<tr style='border-bottom: 1px solid lightgrey;'>
                ${["funcClass", "vmtMod", "vmtObs", "vmtDiff", "vmtDiffPct"].map((d, i) => {
                    // Check if the current cell is one of the numeric columns that need formatting
                    let formattedValue;
                    if (i === 4 || i === 6) {
                        formattedValue = formatNumber(row[d], true);  // True for percentage formatting
                    } else if ((i >= 1 && i <= 3) || i==5) {
                        formattedValue = formatNumber(row[d]);
                    } else {
                        formattedValue = row[d];
                    }
                    return html`<td style='text-align: ${i === 0 ? "left" : "right"}; padding: 5px; font-weight: ${isBold ? 'bold' : 'normal'};'>${formattedValue}</td>`;
                })}
            </tr>`;
        })}
    </tbody>
</table>`
```

:::
::: {.column width="35%"}

```{ojs}
html`<h4>&nbsp;</h4>`
keyVmt = Legend(bChartVmt.scales.color, {title: "Data Source"})

bChartVmt = GroupedBarChart(filtered_vmtDataL, {
    x: d => d.funcClass,
    y: d => d.ViewValue,
    z: d => d.DataSource,
    xDomain: ['Freeway','Principal','Minor','Collector','All Roadways'],
    yLabel: "VMT (millions)",
    zDomain: ['Model','Observed'],
    width: 320,
    height: 175,
    colors: ["#376092", "#77933c"]
})
```

:::
::::

:::: {.columns}
::: {.column width="50%"}

```{ojs}
import {max} from 'd3-array';
```

```{ojs}

maxVal = {
  return Math.max(
    d3.max(filtered_allvehplotData, d => d.volObs),
    d3.max(filtered_allvehplotData, d => d.volMod)
  );
}

```

```{ojs}
html`<h4>2c. Model vs Observed Volumes</h4>`
Plot.plot({
  grid: true,
  width: 460,
  height: 300,
  marginRight: 40,
  x: {
    label: "Observed Volume (thousands)",
    domain: [0, maxVal]
  },
  y: {
    label: "Model Volume (thousands)",
    domain: [0, maxVal]
  },
  marks: [
    Plot.dot(filtered_allvehplotData, {
      x: "volObs",
      y: "volMod",
      r: 1,
      fill: "rgb(80, 116, 230)",
      fillOpacity: 0.5,
      stroke: "none"
    }),
    Plot.link([0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4], {
      x1: 0,
      y1: 0,
      x2: maxVal,
      y2: (k) => maxVal * k,
      strokeOpacity: (k) => k === 1 ? 1 : 0.2,
      stroke: "red",
      strokeWidth: (k) => k === 1 ? 2 : 1.5
    }),
    Plot.text([0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4], {
      x: maxVal,
      y: (k) => maxVal * k,
      text: ((f) => (k) => k === 1 ? "Equal" : f(k - 1))(d3.format("+.0%")),
      textAnchor: "start",
      dx: 6
    }),
    Plot.linearRegressionY(filtered_allvehplotData, {
        x: "volObs",
        y: "volMod",
        stroke: "rgb(80, 116, 230)",
        strokeDasharray: "4 4",  // This creates a dashed line pattern,
        strokeWidth: 2 
    })
  ]
})
```
:::
::: {.column width="50%"}

```{ojs}
html`<h4>2d. Segment Percent Error</h4>`
// volErrorPct
Plot.plot({
  grid: true,
  width: 460,
  height: 300,
  marginRight: 40,
  x: {
    label: "Observed Volume (thousands)",
    domain: [0, maxVal]
  },
  y: {
    label: "Percent Error",
    domain: [-2, 2],
    tickFormat: d3.format(".0%")
  },
  marks: [
    Plot.dot(filtered_allvehplotData, {
      x: "volObs",
      y: "volErrorPct",
      r: 1,
      fill: "rgb(80, 116, 230)",
      fillOpacity: 0.5,
      stroke: "none"
    }),
    Plot.ruleY([2], {
      x1: 0,
      x2: 1,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([1], {
      y1: 1,
      y2: 2,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([1], {
      x1: 1,
      x2: 2.5,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([2.5], {
      y1: 0.5,
      y2: 1.0,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([0.5], {
      x1: 2.5,
      x2: 5,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([5], {
      y1: 0.25,
      y2: 0.50,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([0.25], {
      x1: 5,
      x2: 10,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([10], {
      y1: 0.20,
      y2: 0.25,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([0.20], {
      x1: 10,
      x2: 25,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([25], {
      y1: 0.15,
      y2: 0.20,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([0.15], {
      x1: 25,
      x2: 50,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([50], {
      y1: 0.10,
      y2: 0.15,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([0.10], {
      x1: 50,
      x2: 300,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-2], {
      x1: 0,
      x2: 1,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([1], {
      y1: -1,
      y2: -2,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-1], {
      x1: 1,
      x2: 2.5,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([2.5], {
      y1: -0.5,
      y2: -1.0,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-0.5], {
      x1: 2.5,
      x2: 5,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([5], {
      y1: -0.25,
      y2: -0.50,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-0.25], {
      x1: 5,
      x2: 10,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([10], {
      y1: -0.20,
      y2: -0.25,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-0.20], {
      x1: 10,
      x2: 25,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([25], {
      y1: -0.15,
      y2: -0.20,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-0.15], {
      x1: 25,
      x2: 50,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleX([50], {
      y1: -0.10,
      y2: -0.15,
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([-0.10], {
      x1: 50,
      x2: 300,
      stroke: "red",
      strokeWidth: 2
    })
  ]
})
```


:::
::::

```{ojs}
//|label: fig-assign-validation
//|fig-cap: Detailed Model vs Observed Comparison of Highway Assignment
tbEmptyCell2 = 1
```


:::


::: {.content-hidden when-format="html"}

![Average Daily Comparison by Facility Type by Region.](_pictures/7-plot1.png){#fig-pdf-ave-ft}


## Validation Charts
Write some words here.

![Volume Comparison -- All Vehicles.](_pictures/7-plot2.png){#fig-allvehicles height="60%"}

![Volume Comparison -- Passenger Cars.](_pictures/7-plot3.png){#fig-pc height="60%"}

![Volume Comparison -- Medium Trucks.](_pictures/7-plot4.png){#fig-md-trucks height="60%"}

![Volume Comparison -- Heavy Trucks.](_pictures/7-plot5.png){#fig-hv-trucks height="60%"}


:::

## Map Comparison

The maps in @fig-map shows a comparison of segment level model vs observed volumes by vehicle types. Blue represents model lower than observed and red represent model volume higher than observed.

![Segment-Level Model vs Observed Volume Comparison by Vehicle Type](_pictures/7-plot6.png){#fig-map}

Looking at the *All Vehicles* map, the model volumes are lower than observed for by more than 15,000 vehicles per day for the east side of I-215 and for I-15 through northern Utah County. Model volumes are higher than observed volumes by more than than 15,000 vehicles for I-15 in southern Salt lake County and for I-15 in Utah County between Springville and Spanish Fork. When looking at these areas by vehicle type, the drop in *Cars and Light Trucks* are actual greater since the *Medium Trucks* and *Heavy Trucks* in these areas are greater in the model vs observed. Outside of these areas, the volume differences between model and observed are relatively minor.

The lower arterial model vs observed volumes of *Heavy Trucks* on 9000 South in Salt Lake County was further investigated. The *Heavy Truck* observed volume for this roadway seemed much higher than expected for this roadway. The lower volumes are likely due to the observed data and not anything in the model.

