---
execute:
    echo: false
    message: false
    warning: false
engine: knitr
prefer-html: true
---

# Test Map
```{r}
library(reticulate)
library(tidyverse)
library(sf)
library(leaflet)
```

```{r}
segs <- st_read("A:/1 - TDM/1 - Input Dev/6 - Segment/0 - Segment Shapefile/Master_Segs_withFactors_20220915/Master_Segs_withFactors_20220915shp.shp") %>%
  st_transform(4326)
```

```{r}
leaflet() %>%
  addTiles() %>%
  addPolylines(data=segs$geometry,
               weight = segs$AADT2019 / 10000
  )
```

# Model Results - Comparison with v8.3.2


```{python}
import pandas as pd
import plotly as py
import plotly.graph_objects as go
import plotly.express as px 
import ipywidgets as widgets
import numpy as np
from scipy import special
import time
import math as ms
import sys

sys.path.insert(0, '..\..\Resources\Python-Functions')
import BigQuery
 
client = BigQuery.getBigQueryClient_TDMScenarios()
```

```{python}
# include in all scenario groups
lstIncludeInAll = ['BY','TIP']

# dataframe to create subcategories
dfModeGroups = pd.DataFrame([
    ['Walk'     ,'1: Non-Motorized'         ],
    ['Bike'     ,'1: Non-Motorized'         ],
    ['Walk'     ,'1a: Walk'                 ],
    ['Bike'     ,'1b: Bike'                 ],
    ['Auto'     ,'2: Auto'                  ],
    ['SchoolBus','3: SchoolBus'             ],
    ['LCL'      ,'4: Transit'               ],
    ['COR'      ,'4: Transit'               ],
    ['EXP'      ,'4: Transit'               ],
    ['BRT'      ,'4: Transit'               ],
    ['LRT'      ,'4: Transit'               ],
    ['CRT'      ,'4: Transit'               ],
    ['LCL'      ,'4a: Local Bus'            ],
    ['COR'      ,'4b: Core Bus'             ],
    ['EXP'      ,'4c: Express Bus'          ],
    ['BRT'      ,'4d: Bus-Rapid Transit'    ],
    ['LRT'      ,'4e: Light-Rail Transit'   ],
    ['CRT'      ,'4f: Commuter-Rail Transit'],
    ['Walk'     ,'0: Total'                 ],
    ['Bike'     ,'0: Total'                 ],
    ['Auto'     ,'0: Total'                 ],
    ['SchoolBus','0: Total'                 ],
    ['LCL'      ,'0: Total'                 ],
    ['COR'      ,'0: Total'                 ],
    ['EXP'      ,'0: Total'                 ],
    ['BRT'      ,'0: Total'                 ],
    ['LRT'      ,'0: Total'                 ],
    ['CRT'      ,'0: Total'                 ]]
,columns=('MODE','modeGroup'))
#dfModeGroups
```

```{python}
# FILTER
#strSQLWhere = ' WHERE NOT (t.scenarioID = 33)'
strSQLWhere = ''

# merge scenario data onto transit share data

# read transit summary from biq query
dfTransitSummary = client.query("SELECT * FROM tdm-scenarios.tdm_scenarios_output.transit_share AS t" + strSQLWhere).to_dataframe()
#display(dfTransitSummary)

dfRouteSummary = client.query("SELECT * FROM tdm-scenarios.tdm_scenarios_output.route_summary AS t" + strSQLWhere).to_dataframe()
#display(dfRouteSummary)

# read scenarios data biq query
dfScenarios = client.query("SELECT * FROM tdm-scenarios.tdm_scenarios_output.scenarios AS t" + strSQLWhere).to_dataframe()
#display(dfScenarios)

# merge two dataframes
dfTransitSummaryWithScenarioData = pd.DataFrame.merge(dfScenarios,dfTransitSummary,on='scenarioID')
#display(dfTransitSummaryWithScenarioData)

# merge two dataframes
dfRouteSummaryWithScenarioData = pd.DataFrame.merge(dfScenarios,dfRouteSummary,on='scenarioID')
#display(dfTransitSummaryWithScenarioData)

# merge to mode groupings dataframe
dfTransitSummaryPlotData = pd.DataFrame.merge(dfTransitSummaryWithScenarioData,dfModeGroups,on='MODE')
#dfTransitSummaryPlotData
```

```{python}
#Transit Ridership Plotting Function

import math

def update_plot(tdmVersionsWithDate, scenarioGroups, modeGroups, trippurps, periods):

    data = []

    for v in tdmVersionsWithDate:
        for g in scenarioGroups:
            for m in modeGroups:

                # only do if data in dataframe since BY data is concatonated later
                if dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==v) & (dfTransitSummaryPlotData['scenarioGroup'].isin([g])) & (dfTransitSummaryPlotData['modeGroup']==m) & (dfTransitSummaryPlotData['TRIPPURP'].isin(trippurps)) & (dfTransitSummaryPlotData['PERIOD'].isin(periods))].shape[0]>1:

                    # data for plotting from filtered dataframe}
                    plotdata = dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==v) & (dfTransitSummaryPlotData['scenarioGroup'].isin(lstIncludeInAll + [g])) & (dfTransitSummaryPlotData['modeGroup']==m) & (dfTransitSummaryPlotData['TRIPPURP'].isin(trippurps)) & (dfTransitSummaryPlotData['PERIOD'].isin(periods))]

                    #display(plotdata)

                    plotdata = plotdata.groupby(['scenarioYear'], as_index=False).agg(TRIPS=('TRIPS','sum'))

                    # fill any NaN values with zeros
                    plotdata = plotdata.fillna(0)

                    #display(plotdata)

                    xplot = plotdata['scenarioYear']
                    yplot = plotdata['TRIPS'       ]

                    trace1 = go.Scatter(
                        x=xplot,
                        y=yplot,
                        mode='markers+lines',
                        name= v + ' ' + g + ' ' + m,
                        marker=dict(size=12,
                                line=dict(width=2,
                                            color='DarkSlateGrey'))#,
                        #stackgroup='one',
                        #groupnorm='percent' # sets the normalization for the sum of the stackgroup
        #                line=dict(
        #                    shape='spline'
        #                )
                    )
                    data.append(trace1)


    layout = go.Layout(
        #title='Trips by Mode (' + '/'.join(trippurps) + ' ' + '/'.join(periods) + ')',
        yaxis=dict(
            title='Trips',
            rangemode = 'tozero'#,
            #range=(0,np.null)
        ),
        xaxis=dict(
            title='Year',
            range=(2018,2051)
        ),
        width=800,
        height=450,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01
        )
    )
    
    fig = go.Figure(data=data, layout=layout)
    return fig
```

```{python}
#Transit Share Plotting Function

import math

def update_plot_stackedarea(tdmVersionWithDate, scenarioGroup, modeGroups, trippurps, periods):

    data = []

    modeGroups = sorted(modeGroups)

    for m in modeGroups: 
        # only do if data in dataframe since BY data is concatonated later
        if dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==tdmVersionWithDate) &
                                    (dfTransitSummaryPlotData['scenarioGroup'     ]==scenarioGroup     ) &
                                    (dfTransitSummaryPlotData['modeGroup'         ]==m                 ) &
                                    (dfTransitSummaryPlotData['TRIPPURP'          ].isin(trippurps)    ) &
                                    (dfTransitSummaryPlotData['PERIOD'            ].isin(periods)      )].shape[0]>1:

            # data for plotting from filtered dataframe}
            plotdata = dfTransitSummaryPlotData[(dfTransitSummaryPlotData['tdmVersionWithDate']==tdmVersionWithDate                    ) &
                                                (dfTransitSummaryPlotData['scenarioGroup'     ].isin(lstIncludeInAll + [scenarioGroup])) &
                                                (dfTransitSummaryPlotData['modeGroup'         ]==m                                     ) &
                                                (dfTransitSummaryPlotData['TRIPPURP'          ].isin(trippurps)                        ) &
                                                (dfTransitSummaryPlotData['PERIOD'            ].isin(periods)                          )]

            #display(plotdata)

            plotdata = plotdata.groupby(['scenarioYear'], as_index=False).agg(TRIPS=('TRIPS','sum'))

            # fill any NaN values with zeros
            plotdata = plotdata.fillna(0)

            #display(plotdata)

            xplot = plotdata['scenarioYear']
            yplot = plotdata['TRIPS'       ]

            trace1 = go.Scatter(
                x=xplot,
                y=yplot,
                mode='lines',
                name= m,
                stackgroup='one'#,
                #groupnorm='percent' # sets the normalization for the sum of the stackgroup
            )
            data.append(trace1)


    layout = go.Layout(
        #title=tdmVersionWithDate + ' Trips Mode Split (' + '/'.join(trippurps) + ' ' + '/'.join(periods) + ')',
        yaxis=dict(
            title='Trips'#,
            #rangemode = 'tozero',
            #ticksuffix='%',
            #range=(0,100)
        ),
        xaxis=dict(
            title='Year'#,
            #range=(2018,2051)
        ),
        width=950,
        height=400
    )
    
    fig2 = go.Figure(data=data, layout=layout)
    return fig2
```

```{python}
#PLOTTING FUNCTION

import math

def update_plot_stackedarea_boardings(tdmVersionWithDate, scenarioGroup):

    data = []

    modes = sorted(dfRouteSummaryWithScenarioData['MODE'].unique())

    for m in modes: 
        # only do if data in dataframe since BY data is concatonated later
        if dfRouteSummaryWithScenarioData[(dfRouteSummaryWithScenarioData['tdmVersionWithDate']==tdmVersionWithDate) &
                                          (dfRouteSummaryWithScenarioData['scenarioGroup'     ]==scenarioGroup     ) &
                                          (dfRouteSummaryWithScenarioData['MODE'              ]==m                 )].shape[0]>1:

            # data for plotting from filtered dataframe}
            plotdata = dfRouteSummaryWithScenarioData[(dfRouteSummaryWithScenarioData['tdmVersionWithDate']==tdmVersionWithDate                    ) &
                                                      (dfRouteSummaryWithScenarioData['scenarioGroup'     ].isin(lstIncludeInAll + [scenarioGroup])) &
                                                      (dfRouteSummaryWithScenarioData['MODE'              ]==m                                     )]

            #display(plotdata)

            plotdata = plotdata.groupby(['scenarioYear'], as_index=False).agg(BOARDINGS=('DY_BRDA','sum'))

            # fill any NaN values with zeros
            plotdata = plotdata.fillna(0)

            #display(plotdata)

            xplot = plotdata['scenarioYear']
            yplot = plotdata['BOARDINGS'   ]

            trace1 = go.Scatter(
                x=xplot,
                y=yplot,
                mode='lines',
                name= 'Mode ' + str(m),
                stackgroup='one'#,
                #groupnorm='percent' # sets the normalization for the sum of the stackgroup
            )
            data.append(trace1)


    layout = go.Layout(
        #title=tdmVersionWithDate + ' Boardings by Mode',
        yaxis=dict(
            title='Trips'#,
            #rangemode = 'tozero',
            #ticksuffix='%',
            #range=(0,100)
        ),
        xaxis=dict(
            title='Year'#,
            #range=(2018,2051)
        ),
        width=840,
        height=400
    )
    
    fig3 = go.Figure(data=data, layout=layout)
    return (fig3)
```
## Transit Comparisons

### Transit Ridership
```{python}
#| label: fig-hy-tr-all
#| fig-cap: "Daily transit ridership - All Modes"
#| cap-location: margin
#| column: screen-inset-right
#| message: false

updatefig1 = update_plot(
    ['WF TDM v8.3.2 - 2022-02-04a','WF TDM v9.0 - 2022-12-19'], 
    ['RTP'], 
    ['4: Transit'], 
    ['HBC', 'HBO', 'HBS', 'HBW', 'NHB'], 
    ['Pk','Ok']
)
py.offline.init_notebook_mode(connected=True)
py.offline.plot(updatefig1, filename="plot1.html", auto_open = False)
```

```{r, echo=FALSE}
htmltools::includeHTML("plot1.html")
```

```{python}
#| label: fig-dy-tr-hbc
#| fig-cap: "Daily transit ridership - HBC"
#| cap-location: margin
#| column: screen-inset-right

updatefig2 = update_plot(
    ['WF TDM v8.3.2 - 2022-02-04a','WF TDM v9.0 - 2022-12-19'], 
    ['RTP'], 
    ['4: Transit'], 
    ['HBC'], 
    ['Pk','Ok']
)
py.offline.plot(updatefig2, filename="plot2.html", auto_open = False)
```

```{r, echo=FALSE}
htmltools::includeHTML("plot2.html")
```

### Transit Share

```{python}
#| label: fig-shr-tr-all-832
#| fig-cap: "Transit ridership share by transit mode - v8.3.2"
#| cap-location: margin
#| column: screen-inset-right

updatefig3 = update_plot_stackedarea(
    'WF TDM v8.3.2 - 2022-02-04a', 
    'RTP', 
    ['4a: Local Bus','4b: Core Bus','4c: Express Bus','4d: Bus-Rapid Transit','4e: Light-Rail Transit','4f: Commuter-Rail Transit'], 
    ['HBC', 'HBO', 'HBS', 'HBW', 'NHB'], 
    ['Pk','Ok']
)
py.offline.plot(updatefig3, filename="plot3.html", auto_open = False)
```

```{r, echo=FALSE}
htmltools::includeHTML("plot3.html")
```

```{python}
#| label: fig-shr-tr-all-9
#| fig-cap: "Transit ridership share by transit mode - v9.0"
#| cap-location: margin
#| column: screen-inset-right

updatefig4 = update_plot_stackedarea(
    'WF TDM v9.0 - 2022-12-19', 
    'RTP', 
    ['4a: Local Bus','4b: Core Bus','4c: Express Bus','4d: Bus-Rapid Transit','4e: Light-Rail Transit','4f: Commuter-Rail Transit'], 
    ['HBC', 'HBO', 'HBS', 'HBW', 'NHB'], 
    ['Pk','Ok']
)
py.offline.plot(updatefig4, filename="plot4.html", auto_open = False)
```

```{r, echo=FALSE}
htmltools::includeHTML("plot4.html")
```

### Transit Boardings


```{python}
#| label: fig-brd-832
#| fig-cap: "Transit boardings share by transit mode - v8.3.2"
#| cap-location: margin
#| column: screen-inset-right

updatefig5 = update_plot_stackedarea_boardings('WF TDM v8.3.2 - 2022-02-04a', 'RTP')
py.offline.plot(updatefig5, filename="plot5.html", auto_open = False)
```

```{r, echo=FALSE}
htmltools::includeHTML("plot5.html")
```

```{python}
#| label: fig-brd-9
#| fig-cap: "Transit boardings share by transit mode - v9.0"
#| cap-location: margin
#| column: screen-inset-right

updatefig6 = update_plot_stackedarea_boardings('WF TDM v9.0 - 2022-12-19', 'RTP')
py.offline.plot(updatefig6, filename="plot6.html", auto_open = False)
```

```{r, echo=FALSE}
htmltools::includeHTML("plot6.html")
```
